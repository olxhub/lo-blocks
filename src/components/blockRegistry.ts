// src/components/blockRegistry.ts
//
// Block Registry - the authoritative map of OLX tag names to block definitions.
//
// Merges autogenerated imports (blockRegistryAutogen.ts) with runtime metadata
// (blockMetadataAutogen.json), adds dynamically-generated blocks (MATCH_BLOCKS),
// and validates all blocks before export.
//
import * as BlockRegistryAutogen from './blockRegistryAutogen';
import blockMetadata from './blockMetadataAutogen.json';
import createStubBlock from '@/components/blocks/utility/StubBlock';
import { MATCH_BLOCKS } from '@/lib/blocks/createGrader';
import type { OLXTag, LoBlock } from '@/lib/types';

// Merge metadata onto block objects
export const BLOCK_REGISTRY = Object.fromEntries(
  Object.entries(BlockRegistryAutogen).map(([name, block]) => {
    const meta = blockMetadata.blocks[name];
    if (meta) {
      Object.assign(block, meta);
    }
    return [name, block];
  })
);

// Add Match blocks auto-generated by createGrader
// These are the rule variants (e.g., StringMatch) for use inside RulesGrader
Object.entries(MATCH_BLOCKS).forEach(([tag, block]: [OLXTag, LoBlock]) => {
  BLOCK_REGISTRY[tag] = block;
});

// Export build metadata for debugging/cache invalidation
export const BUILD_META = blockMetadata.meta;

// Structural marker blocks - parsed by parent blocks, not rendered directly
const STUB_BLOCKS = {
  MainPane: {
    description: 'Main content area marker for SideBarPanel layout',
    internal: true,
    readme: 'src/components/blocks/utility/StubBlocks/MainPane.md'
  },
  Sidebar: {
    description: 'Sidebar content marker for SideBarPanel layout',
    internal: true,
    readme: 'src/components/blocks/utility/StubBlocks/Sidebar.md'
  }
};

Object.entries(STUB_BLOCKS).forEach(([name, options]) => {
  const block = createStubBlock(name, options);
  block.readme = options.readme;
  BLOCK_REGISTRY[name] = block;
});

// Validate all blocks
function assertValidBlock(block, name) {
  if (typeof block !== "object") {
    console.log("Failed to validate", name, block, typeof block, block.name);
    throw new Error(
      `Block "${name}" is invalid. This may be due to importing a "use client" component in a server context. ` +
      `Make sure all client components are only used in client files.`
    );
  }
  if (!block._isBlock) {
    throw new Error(
      `Block "${name}" does not appear to be a valid block (missing "_isBlock" flag). ` +
      `Make sure it's created with createBlock().`
    );
  }
}

Object.entries(BLOCK_REGISTRY).forEach(([name, entry]) => {
  assertValidBlock(entry, name);
});
