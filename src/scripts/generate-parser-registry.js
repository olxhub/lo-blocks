// src/scripts/generate-parser-registry.js
// Generates a registry mapping PEG content extensions to their compiled parsers
import { promises as fs } from 'fs';
import path from 'path';
import { glob } from 'glob';

const blocksDir = 'src/components/blocks';
const templateDir = 'src/lib/template';
const outputFile = 'src/generated/parserRegistry.ts';

async function generateParserRegistry() {
  const parserFiles = [
    ...(await glob(`${blocksDir}/**/_*Parser.js`)),
    ...(await glob(`${templateDir}/**/_*Parser.js`))
  ];

  // Use a Map to dedupe by extension (first found wins)
  const entriesMap = new Map();

  for (const parserFile of parserFiles) {
    // Extract grammar name from _fooParser.js -> foo
    const basename = path.basename(parserFile);
    const match = basename.match(/^_(.+)Parser\.js$/);
    if (!match) continue;

    const grammarName = match[1];
    const extension = `${grammarName}peg`;

    // Skip if we already have this extension
    if (entriesMap.has(extension)) continue;

    const relativePath = parserFile.startsWith('src/')
      ? '@/' + parserFile.slice(4).replace(/\.js$/, '')
      : parserFile;

    // Grammar file is in same directory as parser, named {grammarName}.pegjs
    const grammarDir = path.dirname(parserFile);
    const grammarFile = path.join(grammarDir, `${grammarName}.pegjs`);

    // Only include if the grammar source file actually exists in this directory
    // (avoids picking up duplicate compiled parsers without their source)
    try {
      await fs.access(grammarFile);
    } catch {
      continue; // Grammar file doesn't exist here, skip this parser
    }

    entriesMap.set(extension, {
      extension,
      grammarName,
      importPath: relativePath,
      grammarDir: grammarDir.startsWith('src/') ? '@/' + grammarDir.slice(4) : grammarDir
    });
  }

  const entries = Array.from(entriesMap.values());

  // Generate TypeScript registry file
  const imports = entries.map((e, i) =>
    `import * as parser_${i} from '${e.importPath}';`
  ).join('\n');

  const registryEntries = entries.map((e, i) =>
    `  '${e.extension}': parser_${i}`
  ).join(',\n');

  const extensionList = entries.map(e => `'${e.extension}'`).join(', ');

  const grammarInfoEntries = entries.map(e =>
    `  '${e.extension}': { grammarName: '${e.grammarName}', grammarDir: '${e.grammarDir}' }`
  ).join(',\n');

  const content = `// AUTO-GENERATED - DO NOT EDIT
// Generated by: npm run build:parser-registry
// Maps PEG content file extensions to their compiled parsers

${imports}

export type PEGContentExtension = ${entries.map(e => `'${e.extension}'`).join(' | ')};

export const PEG_CONTENT_EXTENSIONS: readonly PEGContentExtension[] = [${extensionList}] as const;

interface PEGParser {
  parse: (input: string) => unknown;
}

interface GrammarInfo {
  grammarName: string;
  grammarDir: string;
}

export const parserRegistry: Record<PEGContentExtension, PEGParser> = {
${registryEntries}
};

export const grammarInfo: Record<PEGContentExtension, GrammarInfo> = {
${grammarInfoEntries}
};

export function getParserForExtension(ext: string): PEGParser | undefined {
  const normalized = ext.replace(/^\\./, '').toLowerCase();
  return parserRegistry[normalized as PEGContentExtension];
}

export function isPEGContentExtension(ext: string): ext is PEGContentExtension {
  const normalized = ext.replace(/^\\./, '').toLowerCase();
  return PEG_CONTENT_EXTENSIONS.includes(normalized as PEGContentExtension);
}

/**
 * Get the path to the preview OLX file for a PEG content extension.
 * Preview files are named {grammarName}.pegjs.preview.olx
 * Returns the path relative to project root (e.g., "src/components/blocks/Chat/chat.pegjs.preview.olx")
 */
export function getPreviewPath(ext: string): string | undefined {
  const normalized = ext.replace(/^\\./, '').toLowerCase();
  const info = grammarInfo[normalized as PEGContentExtension];
  if (!info) return undefined;
  // Convert @/foo to src/foo for file system access
  const dir = info.grammarDir.replace(/^@\\//, 'src/');
  return \`\${dir}/\${info.grammarName}.pegjs.preview.olx\`;
}
`;

  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  await fs.writeFile(outputFile, content);
  console.log(`✅ Generated ${outputFile} with ${entries.length} parsers:`);
  entries.forEach(e => console.log(`   - ${e.extension} → ${e.importPath}`));
}

generateParserRegistry().catch(err => {
  console.error('❌ Parser registry generation failed:', err);
  process.exit(1);
});
