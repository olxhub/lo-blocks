// src/scripts/generate-parser-registry.js
// Generates a registry mapping PEG content extensions to their compiled parsers
import { promises as fs } from 'fs';
import path from 'path';
import { glob } from 'glob';

const blocksDir = 'src/components/blocks';
const templateDir = 'src/lib/template';
const outputFile = 'src/generated/parserRegistry.ts';

async function generateParserRegistry() {
  const parserFiles = [
    ...(await glob(`${blocksDir}/**/_*Parser.js`)),
    ...(await glob(`${templateDir}/**/_*Parser.js`))
  ];

  // Use a Map to dedupe by extension (first found wins)
  const entriesMap = new Map();

  for (const parserFile of parserFiles) {
    // Extract grammar name from _fooParser.js -> foo
    const basename = path.basename(parserFile);
    const match = basename.match(/^_(.+)Parser\.js$/);
    if (!match) continue;

    const grammarName = match[1];
    const extension = `${grammarName}peg`;

    // Skip if we already have this extension
    if (entriesMap.has(extension)) continue;

    const relativePath = parserFile.startsWith('src/')
      ? '@/' + parserFile.slice(4).replace(/\.js$/, '')
      : parserFile;

    entriesMap.set(extension, {
      extension,
      grammarName,
      importPath: relativePath
    });
  }

  const entries = Array.from(entriesMap.values());

  // Generate TypeScript registry file
  const imports = entries.map((e, i) =>
    `import * as parser_${i} from '${e.importPath}';`
  ).join('\n');

  const registryEntries = entries.map((e, i) =>
    `  '${e.extension}': parser_${i}`
  ).join(',\n');

  const extensionList = entries.map(e => `'${e.extension}'`).join(', ');

  const content = `// AUTO-GENERATED - DO NOT EDIT
// Generated by: npm run build:parser-registry
// Maps PEG content file extensions to their compiled parsers

${imports}

export type PEGContentExtension = ${entries.map(e => `'${e.extension}'`).join(' | ')};

export const PEG_CONTENT_EXTENSIONS: readonly PEGContentExtension[] = [${extensionList}] as const;

interface PEGParser {
  parse: (input: string) => unknown;
}

export const parserRegistry: Record<PEGContentExtension, PEGParser> = {
${registryEntries}
};

export function getParserForExtension(ext: string): PEGParser | undefined {
  const normalized = ext.replace(/^\\./, '').toLowerCase();
  return parserRegistry[normalized as PEGContentExtension];
}

export function isPEGContentExtension(ext: string): ext is PEGContentExtension {
  const normalized = ext.replace(/^\\./, '').toLowerCase();
  return PEG_CONTENT_EXTENSIONS.includes(normalized as PEGContentExtension);
}
`;

  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  await fs.writeFile(outputFile, content);
  console.log(`✅ Generated ${outputFile} with ${entries.length} parsers:`);
  entries.forEach(e => console.log(`   - ${e.extension} → ${e.importPath}`));
}

generateParserRegistry().catch(err => {
  console.error('❌ Parser registry generation failed:', err);
  process.exit(1);
});
