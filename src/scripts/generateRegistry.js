// src/scripts/generateRegistry.js
// Generic registry generator for blocks, CSS, docs, etc.
import fs from 'fs';
import path from 'path';
import { minimatch } from 'minimatch';

const blocksDir = path.resolve(process.cwd(), 'src/components/blocks/');
const ignoreFile = path.join(blocksDir, '.blockignore');

// Registry type configurations
const registryTypes = {
  blocks: {
    filePattern: /^[A-Z].*\.(jsx|tsx|js|ts)$/,
    outputFile: path.resolve(process.cwd(), 'src/components/blockRegistry.js'),
    fileHeader: `// THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY\n// npm run build:gen-registry\n\n`,
    reducer: (files, outputFile) => {
      return files.reduce((content, filePath) => {
        const relativePathRaw = './' + path.relative(path.dirname(outputFile), filePath).replace(/\\/g, '/');
        const ext = path.extname(relativePathRaw);
        const relativePath = relativePathRaw.slice(0, -ext.length);
        const baseName = path.basename(filePath, ext);
        return content + `export { default as ${baseName} } from '${relativePath}';\n`;
      }, '');
    }
  },

  css: {
    filePattern: /\.css$/,
    excludePattern: /^_|\.module\./,
    outputFile: path.resolve(process.cwd(), 'src/styles/components.css'),
    fileHeader: `/* THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY */\n/* Generated by: npm run build:gen-registry */\n/* Auto-imports all component CSS files from src/components/blocks/ */\n\n`,
    reducer: (files, outputFile) => {
      return files.reduce((content, filePath) => {
        const relativePath = path.relative(path.dirname(outputFile), filePath).replace(/\\/g, '/');
        const baseName = path.basename(filePath, '.css');
        return content + `/* ${baseName} component styles */\n@import "./${relativePath}";\n\n`;
      }, '');
    }
  }
};

function readBlockIgnore(ignorePath) {
  if (!fs.existsSync(ignorePath)) return [];
  return fs
    .readFileSync(ignorePath, 'utf8')
    .split('\n')
    .map(line => line.trim())
    .filter(line => line && !line.startsWith('#'));
}

function shouldExclude(filePath, ignorePatterns, excludePattern) {
  const relPath = path.relative(blocksDir, filePath).replace(/\\/g, '/');

  // Check ignore patterns
  for (const pattern of ignorePatterns) {
    if (minimatch(relPath, pattern)) return true;
  }

  // Check exclude pattern (e.g., for CSS modules)
  const filename = path.basename(filePath);
  if (excludePattern && excludePattern.test(filename)) return true;

  // Check for @registry-ignore comment
  const content = fs.readFileSync(filePath, 'utf8');
  if (content.includes('@registry-ignore')) return true;

  return false;
}

function walkDirectories(dirs, filePattern, ignorePatterns, excludePattern) {
  let files = [];

  for (const dir of dirs) {
    if (!fs.existsSync(dir)) continue;
    files = files.concat(walkDir(dir, filePattern, ignorePatterns, excludePattern));
  }

  return files;
}

function walkDir(dir, filePattern, ignorePatterns, excludePattern) {
  let files = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(walkDir(fullPath, filePattern, ignorePatterns, excludePattern));
    } else if (entry.isFile() && filePattern.test(entry.name)) {
      if (!shouldExclude(fullPath, ignorePatterns, excludePattern)) {
        files.push(fullPath);
      }
    }
  }
  return files;
}

function generateRegistry(registryType) {
  const config = registryTypes[registryType];
  const ignorePatterns = readBlockIgnore(ignoreFile);

  // For now, we only search blocksDir, but this could be extended
  // to search multiple directories for multi-repo block sources
  const searchDirs = [blocksDir];

  const files = walkDirectories(
    searchDirs,
    config.filePattern,
    ignorePatterns,
    config.excludePattern
  );

  // Ensure output directory exists
  const outputDir = path.dirname(config.outputFile);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const content = config.fileHeader + config.reducer(files, config.outputFile);

  fs.writeFileSync(config.outputFile, content);
  console.log(`Generated ${registryType} registry at ${config.outputFile} with ${files.length} entries.`);
}

function main() {
  console.log('Generating all registries...');

  for (const registryType of Object.keys(registryTypes)) {
    generateRegistry(registryType);
  }

  console.log('All registries generated successfully.');
}

main();