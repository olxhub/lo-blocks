// src/scripts/generateRegistry.js
// Generic registry generator for blocks, CSS, docs, etc.
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { minimatch } from 'minimatch';

const blocksDir = path.resolve(process.cwd(), 'src/components/blocks/');
const ignoreFile = path.join(blocksDir, '.blockignore');

/**
 * Git Status Tracking
 * ===================
 * Tracks which files are committed, modified, or untracked in git.
 * Used to help authors identify uncommitted documentation/blocks.
 */

/**
 * Get git status for all files in the repository.
 * Returns a Map of relative paths to their git status.
 *
 * Status values:
 * - 'committed': File is tracked and unchanged
 * - 'modified': File is tracked but has changes (staged or unstaged)
 * - 'untracked': File is not tracked by git
 *
 * Returns null if git is unavailable or not in a repo.
 */
function getGitStatusMap() {
  try {
    // Get all untracked and modified files
    const output = execSync('git status --porcelain', {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    });

    const statusMap = new Map();

    for (const line of output.split('\n')) {
      if (!line.trim()) continue;

      // Format: XY filename (where X=staged, Y=unstaged)
      const status = line.slice(0, 2);
      let filePath = line.slice(3);

      // Handle renamed files: "R  old -> new"
      if (filePath.includes(' -> ')) {
        filePath = filePath.split(' -> ')[1];
      }

      // Determine status category
      if (status === '??') {
        statusMap.set(filePath, 'untracked');
      } else {
        // Any other status means modified (staged, unstaged, or both)
        statusMap.set(filePath, 'modified');
      }
    }

    return statusMap;
  } catch (error) {
    // Git not available or not in a repo
    console.warn('Warning: Could not get git status:', error.message);
    return null;
  }
}

/**
 * Get the git status for a specific file path.
 * @param {string} filePath - Path relative to repo root
 * @param {Map|null} gitStatusMap - Pre-computed status map from getGitStatusMap()
 * @returns {'committed'|'modified'|'untracked'|null}
 */
function getFileGitStatus(filePath, gitStatusMap) {
  if (!gitStatusMap) return null;
  return gitStatusMap.get(filePath) || 'committed';
}

/**
 * Block Directory Structure
 * =========================
 * Blocks can be either flat files or directories:
 *
 * Flat file (simple blocks):
 *   src/components/blocks/ActionButton.js
 *
 * Directory (blocks with assets):
 *   src/components/blocks/Chat/
 *     Chat.js          - Block definition (required, exports default block)
 *     _Chat.jsx        - React component (optional, prefixed with _)
 *     Chat.md          - Documentation (optional, matches block name)
 *     Chat.olx         - Example usage (optional)
 *     ChatAdvanced.olx - Additional examples (optional, prefixed with block name)
 *     chat.css         - Styles (optional, auto-aggregated)
 *     chat.pegjs       - PEG grammar (optional, compiled to _chatParser.js)
 *
 * The manifest generator:
 *   1. Finds all block files (capitalized .js/.jsx/.ts/.tsx, not prefixed with _)
 *   2. Imports each block to extract runtime metadata (name, description, fields, etc.)
 *   3. Scans the block's directory for associated assets:
 *      - docs: {BlockName}.md
 *      - examples: {BlockName}*.olx or {BlockName}*.xml
 *   4. Outputs blockManifest.json for use by docs, tooltips, LLM tools, etc.
 *
 * Future: Blueprint-level overrides for custom docs/example paths.
 */

// Registry type configurations
const registryTypes = {
  blocks: {
    filePattern: /^[A-Z].*\.(jsx|tsx|js|ts)$/,
    outputFile: path.resolve(process.cwd(), 'src/components/blockRegistry.js'),
    metadataFile: path.resolve(process.cwd(), 'src/components/blockMetadata.json'),
    fileHeader: `// THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY\n// npm run build:gen-registry\n\n`,
    reducer: (files, outputFile, gitStatusMap) => {
      let imports = '';
      const exports = [];
      const metadata = {};

      for (const filePath of files) {
        const relativePathRaw = './' + path.relative(path.dirname(outputFile), filePath).replace(/\\/g, '/');
        const ext = path.extname(relativePathRaw);
        const relativePath = relativePathRaw.slice(0, -ext.length);
        const baseName = path.basename(filePath, ext);
        const srcPath = path.relative(process.cwd(), filePath).replace(/\\/g, '/');
        const assets = findBlockAssets(filePath, gitStatusMap);

        imports += `import { default as ${baseName} } from '${relativePath}';\n`;
        exports.push(baseName);

        // Build metadata object for this block
        const blockMeta = {
          source: srcPath
        };
        if (assets.blockGitStatus) {
          blockMeta.gitStatus = assets.blockGitStatus;
        }
        if (assets.docs) {
          blockMeta.readme = assets.docs;
          if (assets.docsGitStatus) {
            blockMeta.readmeGitStatus = assets.docsGitStatus;
          }
        }
        if (assets.examples.length > 0) {
          blockMeta.examples = assets.examples;
        }
        metadata[baseName] = blockMeta;
      }

      return {
        registryContent: imports + '\n' + `export { ${exports.join(', ')} };\n`,
        metadata
      };
    }
  },

  css: {
    filePattern: /\.css$/,
    excludePattern: /^_|\.module\./,
    outputFile: path.resolve(process.cwd(), 'src/styles/components.css'),
    fileHeader: `/* THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY */\n/* Generated by: npm run build:gen-registry */\n/* Auto-imports all component CSS files from src/components/blocks/ */\n\n`,
    reducer: (files, outputFile) => {
      return files.reduce((content, filePath) => {
        const relativePath = path.relative(path.dirname(outputFile), filePath).replace(/\\/g, '/');
        const baseName = path.basename(filePath, '.css');
        return content + `/* ${baseName} component styles */\n@import "./${relativePath}";\n\n`;
      }, '');
    }
  }
};

/**
 * Find associated documentation and example files for a block.
 * Follows naming convention: {BlockName}.md for docs, {BlockName}*.olx for examples.
 * Also includes git status for each file.
 *
 * @param {string} blockFilePath - Full path to the block file
 * @param {Map|null} gitStatusMap - Pre-computed git status map
 */
function findBlockAssets(blockFilePath, gitStatusMap) {
  const dir = path.dirname(blockFilePath);
  const blockName = path.basename(blockFilePath, path.extname(blockFilePath));
  const blockRelPath = path.relative(process.cwd(), blockFilePath).replace(/\\/g, '/');

  const assets = {
    docs: null,
    docsGitStatus: null,
    examples: [],
    blockGitStatus: getFileGitStatus(blockRelPath, gitStatusMap)
  };

  if (!fs.existsSync(dir)) return assets;

  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    // Include regular files and symlinks (symlinks to files)
    if (!entry.isFile() && !entry.isSymbolicLink()) continue;

    const entryPath = path.relative(process.cwd(), path.join(dir, entry.name)).replace(/\\/g, '/');

    // Docs: exact match {BlockName}.md
    if (entry.name === `${blockName}.md`) {
      assets.docs = entryPath;
      assets.docsGitStatus = getFileGitStatus(entryPath, gitStatusMap);
    }
    // Examples: {BlockName}*.olx or {BlockName}*.xml
    else if (
      (entry.name.startsWith(blockName) && (entry.name.endsWith('.olx') || entry.name.endsWith('.xml')))
    ) {
      assets.examples.push({
        path: entryPath,
        gitStatus: getFileGitStatus(entryPath, gitStatusMap)
      });
    }
  }

  return assets;
}

function readBlockIgnore(ignorePath) {
  if (!fs.existsSync(ignorePath)) return [];
  return fs
    .readFileSync(ignorePath, 'utf8')
    .split('\n')
    .map(line => line.trim())
    .filter(line => line && !line.startsWith('#'));
}

function shouldExclude(filePath, ignorePatterns, excludePattern) {
  const relPath = path.relative(blocksDir, filePath).replace(/\\/g, '/');

  // Check ignore patterns
  for (const pattern of ignorePatterns) {
    if (minimatch(relPath, pattern)) return true;
  }

  // Check exclude pattern (e.g., for CSS modules)
  const filename = path.basename(filePath);
  if (excludePattern && excludePattern.test(filename)) return true;

  // Check for @registry-ignore comment
  const content = fs.readFileSync(filePath, 'utf8');
  if (content.includes('@registry-ignore')) return true;

  return false;
}

function walkDirectories(dirs, filePattern, ignorePatterns, excludePattern) {
  let files = [];

  for (const dir of dirs) {
    if (!fs.existsSync(dir)) continue;
    files = files.concat(walkDir(dir, filePattern, ignorePatterns, excludePattern));
  }

  return files;
}

function walkDir(dir, filePattern, ignorePatterns, excludePattern) {
  let files = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(walkDir(fullPath, filePattern, ignorePatterns, excludePattern));
    } else if (entry.isFile() && filePattern.test(entry.name)) {
      if (!shouldExclude(fullPath, ignorePatterns, excludePattern)) {
        files.push(fullPath);
      }
    }
  }
  return files;
}

/**
 * Generate registry contents (without writing to disk).
 * Returns { blocks: { content, outputFile, files, metadata, metadataFile }, css: { content, outputFile, files } }
 */
export function generateAllRegistryContents() {
  const ignorePatterns = readBlockIgnore(ignoreFile);
  const gitStatusMap = getGitStatusMap();
  const result = {};

  for (const [name, config] of Object.entries(registryTypes)) {
    const files = walkDirectories(
      [blocksDir],
      config.filePattern,
      ignorePatterns,
      config.excludePattern
    );

    const reducerResult = config.reducer(files, config.outputFile, gitStatusMap);

    // Handle both old (string) and new (object with registryContent + metadata) reducer formats
    if (typeof reducerResult === 'string') {
      result[name] = {
        content: config.fileHeader + reducerResult,
        outputFile: config.outputFile,
        files
      };
    } else {
      result[name] = {
        content: config.fileHeader + reducerResult.registryContent,
        outputFile: config.outputFile,
        files,
        metadata: reducerResult.metadata,
        metadataFile: config.metadataFile
      };
    }
  }

  return result;
}

function generateRegistry(registryType) {
  const all = generateAllRegistryContents();
  const { content, outputFile, metadata, metadataFile } = all[registryType];

  // Ensure output directory exists
  const outputDir = path.dirname(outputFile);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(outputFile, content);
  console.log(`Generated ${registryType} registry at ${outputFile}.`);

  // Write metadata JSON if present (blocks registry)
  if (metadata && metadataFile) {
    const wrapped = {
      meta: getBuildMeta(),
      blocks: metadata
    };
    const metadataContent = JSON.stringify(wrapped, null, 2) + '\n';
    fs.writeFileSync(metadataFile, metadataContent);
    console.log(`Generated ${registryType} metadata at ${metadataFile}.`);
  }
}

/**
 * Get build metadata for the generated files.
 * Includes git info and timestamp for debugging and cache invalidation.
 */
function getBuildMeta() {
  const meta = {
    timestamp: new Date().toISOString()
  };

  try {
    meta.gitHash = execSync('git rev-parse HEAD', {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();

    meta.gitBranch = execSync('git rev-parse --abbrev-ref HEAD', {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();

    // Check if working directory is dirty
    const status = execSync('git status --porcelain', {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();
    meta.dirty = status.length > 0;
  } catch (error) {
    // Git not available - that's fine, just omit git fields
  }

  return meta;
}

function main() {
  console.log('Generating all registries...');

  for (const registryType of Object.keys(registryTypes)) {
    generateRegistry(registryType);
  }

  console.log('All registries generated successfully.');
}

// Only run main() when executed directly, not when imported
const isDirectRun = process.argv[1]?.endsWith('generateRegistry.js');
if (isDirectRun) {
  main();
}
