// src/scripts/generateRegistry.js
// Generic registry generator for blocks, CSS, docs, etc.
import fs from 'fs';
import path from 'path';
import { minimatch } from 'minimatch';

const blocksDir = path.resolve(process.cwd(), 'src/components/blocks/');
const ignoreFile = path.join(blocksDir, '.blockignore');

/**
 * Block Directory Structure
 * =========================
 * Blocks can be either flat files or directories:
 *
 * Flat file (simple blocks):
 *   src/components/blocks/ActionButton.js
 *
 * Directory (blocks with assets):
 *   src/components/blocks/Chat/
 *     Chat.js          - Block definition (required, exports default block)
 *     _Chat.jsx        - React component (optional, prefixed with _)
 *     Chat.md          - Documentation (optional, matches block name)
 *     Chat.olx         - Example usage (optional)
 *     ChatAdvanced.olx - Additional examples (optional, prefixed with block name)
 *     chat.css         - Styles (optional, auto-aggregated)
 *     chat.pegjs       - PEG grammar (optional, compiled to _chatParser.js)
 *
 * The manifest generator:
 *   1. Finds all block files (capitalized .js/.jsx/.ts/.tsx, not prefixed with _)
 *   2. Imports each block to extract runtime metadata (name, description, fields, etc.)
 *   3. Scans the block's directory for associated assets:
 *      - docs: {BlockName}.md
 *      - examples: {BlockName}*.olx or {BlockName}*.xml
 *   4. Outputs blockManifest.json for use by docs, tooltips, LLM tools, etc.
 *
 * Future: Blueprint-level overrides for custom docs/example paths.
 */

// Registry type configurations
const registryTypes = {
  blocks: {
    filePattern: /^[A-Z].*\.(jsx|tsx|js|ts)$/,
    outputFile: path.resolve(process.cwd(), 'src/components/blockRegistry.js'),
    fileHeader: `// THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY\n// npm run build:gen-registry\n\n`,
    reducer: (files, outputFile) => {
      let imports = '';
      let annotations = '';
      const exports = [];

      for (const filePath of files) {
        const relativePathRaw = './' + path.relative(path.dirname(outputFile), filePath).replace(/\\/g, '/');
        const ext = path.extname(relativePathRaw);
        const relativePath = relativePathRaw.slice(0, -ext.length);
        const baseName = path.basename(filePath, ext);
        const srcPath = path.relative(process.cwd(), filePath).replace(/\\/g, '/');
        const assets = findBlockAssets(filePath);

        imports += `import { default as ${baseName} } from '${relativePath}';\n`;
        annotations += `${baseName}.source = '${srcPath}';\n`;
        if (assets.docs) {
          annotations += `${baseName}.readme = '${assets.docs}';\n`;
        }
        if (assets.examples.length > 0) {
          annotations += `${baseName}.examples = ${JSON.stringify(assets.examples)};\n`;
        }
        exports.push(baseName);
      }

      return imports + '\n' + annotations + '\n' + `export { ${exports.join(', ')} };\n`;
    }
  },

  css: {
    filePattern: /\.css$/,
    excludePattern: /^_|\.module\./,
    outputFile: path.resolve(process.cwd(), 'src/styles/components.css'),
    fileHeader: `/* THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY */\n/* Generated by: npm run build:gen-registry */\n/* Auto-imports all component CSS files from src/components/blocks/ */\n\n`,
    reducer: (files, outputFile) => {
      return files.reduce((content, filePath) => {
        const relativePath = path.relative(path.dirname(outputFile), filePath).replace(/\\/g, '/');
        const baseName = path.basename(filePath, '.css');
        return content + `/* ${baseName} component styles */\n@import "./${relativePath}";\n\n`;
      }, '');
    }
  }
};

/**
 * Find associated documentation and example files for a block.
 * Follows naming convention: {BlockName}.md for docs, {BlockName}*.olx for examples.
 */
function findBlockAssets(blockFilePath) {
  const dir = path.dirname(blockFilePath);
  const blockName = path.basename(blockFilePath, path.extname(blockFilePath));
  const assets = { docs: null, examples: [] };

  if (!fs.existsSync(dir)) return assets;

  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    if (!entry.isFile()) continue;

    // Docs: exact match {BlockName}.md
    if (entry.name === `${blockName}.md`) {
      assets.docs = path.relative(process.cwd(), path.join(dir, entry.name)).replace(/\\/g, '/');
    }
    // Examples: {BlockName}*.olx or {BlockName}*.xml
    else if (
      (entry.name.startsWith(blockName) && (entry.name.endsWith('.olx') || entry.name.endsWith('.xml')))
    ) {
      assets.examples.push(
        path.relative(process.cwd(), path.join(dir, entry.name)).replace(/\\/g, '/')
      );
    }
  }

  return assets;
}

function readBlockIgnore(ignorePath) {
  if (!fs.existsSync(ignorePath)) return [];
  return fs
    .readFileSync(ignorePath, 'utf8')
    .split('\n')
    .map(line => line.trim())
    .filter(line => line && !line.startsWith('#'));
}

function shouldExclude(filePath, ignorePatterns, excludePattern) {
  const relPath = path.relative(blocksDir, filePath).replace(/\\/g, '/');

  // Check ignore patterns
  for (const pattern of ignorePatterns) {
    if (minimatch(relPath, pattern)) return true;
  }

  // Check exclude pattern (e.g., for CSS modules)
  const filename = path.basename(filePath);
  if (excludePattern && excludePattern.test(filename)) return true;

  // Check for @registry-ignore comment
  const content = fs.readFileSync(filePath, 'utf8');
  if (content.includes('@registry-ignore')) return true;

  return false;
}

function walkDirectories(dirs, filePattern, ignorePatterns, excludePattern) {
  let files = [];

  for (const dir of dirs) {
    if (!fs.existsSync(dir)) continue;
    files = files.concat(walkDir(dir, filePattern, ignorePatterns, excludePattern));
  }

  return files;
}

function walkDir(dir, filePattern, ignorePatterns, excludePattern) {
  let files = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(walkDir(fullPath, filePattern, ignorePatterns, excludePattern));
    } else if (entry.isFile() && filePattern.test(entry.name)) {
      if (!shouldExclude(fullPath, ignorePatterns, excludePattern)) {
        files.push(fullPath);
      }
    }
  }
  return files;
}

/**
 * Generate registry contents (without writing to disk).
 * Returns { blocks: { content, outputFile, files }, css: { content, outputFile, files } }
 */
export function generateAllRegistryContents() {
  const ignorePatterns = readBlockIgnore(ignoreFile);
  const result = {};

  for (const [name, config] of Object.entries(registryTypes)) {
    const files = walkDirectories(
      [blocksDir],
      config.filePattern,
      ignorePatterns,
      config.excludePattern
    );
    result[name] = {
      content: config.fileHeader + config.reducer(files, config.outputFile),
      outputFile: config.outputFile,
      files
    };
  }

  return result;
}

function generateRegistry(registryType) {
  const all = generateAllRegistryContents();
  const { content, outputFile } = all[registryType];

  // Ensure output directory exists
  const outputDir = path.dirname(outputFile);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(outputFile, content);
  console.log(`Generated ${registryType} registry at ${outputFile}.`);
}

function main() {
  console.log('Generating all registries...');

  for (const registryType of Object.keys(registryTypes)) {
    generateRegistry(registryType);
  }

  console.log('All registries generated successfully.');
}

// Only run main() when executed directly, not when imported
const isDirectRun = process.argv[1]?.endsWith('generateRegistry.js');
if (isDirectRun) {
  main();
}
