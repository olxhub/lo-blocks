// src/scripts/generateBlockRegistry.js
// generateBlockRegistry.js
import fs from 'fs';
import path from 'path';
import { minimatch } from 'minimatch';

const blocksDir = path.resolve(process.cwd(), 'src/components/blocks/');
const outputFile = path.resolve(process.cwd(), 'src/components/blockRegistry.js');
const ignoreFile = path.join(blocksDir, '.blockignore');

function readBlockIgnore(ignorePath) {
  if (!fs.existsSync(ignorePath)) return [];
  return fs
    .readFileSync(ignorePath, 'utf8')
    .split('\n')
    .map(line => line.trim())
    .filter(line => line && !line.startsWith('#'));
}

const blockIgnorePatterns = readBlockIgnore(ignoreFile);

function isBlockFile(filename) {
  return /^[A-Z].*\.(jsx|tsx|js|ts)$/.test(filename);
}

// Optional: exclude StubBlock or any flagged files
function shouldExclude(filePath) {
  // pattern matching (relative to blocksDir)
  const relPath = path.relative(blocksDir, filePath).replace(/\\/g, '/');
  for (const pattern of blockIgnorePatterns) {
    if (minimatch(relPath, pattern)) return true;
  }

  // Example: exclude files containing a specific comment string, e.g. "NO_EXPORT"
  const content = fs.readFileSync(filePath, 'utf8');
  if (content.includes('@block-registry-ignore')) return true;

  return false;
}

function walkDir(dir) {
  let files = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(walkDir(fullPath));
    } else if (entry.isFile() && isBlockFile(entry.name)) {
      if (!shouldExclude(fullPath)) {
        files.push(fullPath);
      }
    }
  }
  return files;
}

// Generate import/export lines relative to blocksDir
function generateExports(files) {
  return files.map(filePath => {
    // Compute relative path from outputFile's directory to the block file
    const relativePathRaw = './' + path.relative(path.dirname(outputFile), filePath).replace(/\\/g, '/');

    const ext = path.extname(relativePathRaw);
    const relativePath = relativePathRaw.slice(0, -ext.length); // strip extension

    const baseName = path.basename(filePath, ext);
    return `export { default as ${baseName} } from '${relativePath}';`;
  });
}

function main() {
  const files = walkDir(blocksDir);
  const exportsLines = generateExports(files);

  const header = `// THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY\n` +
                 `// npm run-script build:gen-block-registry\n\n`;

  const content = header + exportsLines.join('\n') + '\n';

  fs.writeFileSync(outputFile, content);
  console.log(`Generated blockRegistry at ${outputFile} with ${files.length} exports.`);
}

main();
