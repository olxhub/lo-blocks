#!/usr/bin/env node
// src/scripts/clean-translations.ts
//
// Remove all autogenerated translation files from the content directory.
//
// Loads the content store, finds every variant with autogenerated === true,
// resolves its source file via the content store's provenance lookup,
// and deletes via the storage provider (which enforces path safety).
//
// Usage:
//   npm run clean-translations          # dry run (default)
//   npm run clean-translations -- --rm  # actually delete files

import path from 'path';
import fs from 'fs/promises';
import { syncContentFromStorage, getSourceFile } from '../lib/content/syncContentFromStorage';
import { FileStorageProvider } from '../lib/lofs/providers/file';
import type { IdMap, OlxJson, ContentVariant } from '../lib/types';

const contentDir = path.resolve(process.env.OLX_CONTENT_DIR || './content');
const dryRun = !process.argv.includes('--rm');

/** Convert a file:// provenance URI to a provider-relative path. */
function uriToRelPath(fileUri: string): string {
  const absPath = fileUri.startsWith('file://') ? fileUri.slice(7) : fileUri;
  return path.relative(contentDir, absPath);
}

async function main() {
  const provider = new FileStorageProvider(contentDir);
  const { idMap } = await syncContentFromStorage(provider);

  // Collect provider-relative paths of autogenerated files
  const filesToDelete = new Set<string>();

  for (const [blockId, langMap] of Object.entries(idMap as IdMap)) {
    for (const [locale, variant] of Object.entries(langMap) as [ContentVariant, OlxJson][]) {
      if (!variant.autogenerated) continue;

      const fileUri = getSourceFile(blockId, locale);
      if (!fileUri) {
        console.error(`WARNING: autogenerated variant ${blockId}/${locale} has no source file in content store`);
        continue;
      }
      filesToDelete.add(uriToRelPath(fileUri));
    }
  }

  if (filesToDelete.size === 0) {
    console.log('No autogenerated translation files found.');
    process.exit(0);
  }

  if (dryRun) {
    console.log(`Found ${filesToDelete.size} autogenerated translation file(s) (dry run — pass --rm to delete):\n`);
  } else {
    console.log(`Deleting ${filesToDelete.size} autogenerated translation file(s):\n`);
  }

  for (const relPath of filesToDelete) {
    console.log(`  ${dryRun ? 'would delete' : 'deleting'}: ${relPath}`);

    if (!dryRun) {
      await provider.delete(relPath);

      // Remove parent directory if empty (translation subdirs like demos/foo/)
      const parentDir = path.resolve(contentDir, path.dirname(relPath));
      try {
        const entries = await fs.readdir(parentDir);
        if (entries.length === 0) {
          await fs.rmdir(parentDir);
          console.log(`  removed empty directory: ${path.dirname(relPath)}`);
        }
      } catch {
        // Directory already gone or non-empty — fine either way
      }
    }
  }

  console.log('\nDone.');
}

main().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
