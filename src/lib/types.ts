// src/lib/types.ts

export type JSONValue =
  | string
  | number
  | boolean
  | null
  | JSONValue[]
  | { [key: string]: JSONValue };

// Storage API: Grabbing OLX files from disk
export interface FileProvenance {
  type: 'file';
  path: string;
  [key: string]: any;
}

export interface GenericProvenance {
  type: string;
  path?: string;
  [key: string]: any;
}

/** 
  * TODO: These should be a branded or tagged type:
  *   type ProvenanceURI = string & { __brand: "ProvenanceURI" };
  * Then we use this as:
  *   const uri = "file://content/foo.olx" as ProvenanceURI;
  * And it stops being interchangeable with strings.
  */
export type ProvenanceURI = string;
export type OLXId = string;
export type OLXTag = string;

// TODO: Add similar tagged types for things like Block ID, etc.

/** Primary representation for provenance references */
export type Provenance = ProvenanceURI[];

/** Structured representation used in debug output */
export type ProvenanceStruct = FileProvenance | GenericProvenance;
export type ProvenanceEntry = ProvenanceURI | ProvenanceStruct;

// Fields API
export interface FieldInfo {
  type: 'field';
  name: string;
  event: string;
  scope: import('./state/scopes').Scope;
}

export interface FieldInfoByField { [name: string]: FieldInfo; }
export interface FieldInfoByEvent { [event: string]: FieldInfo; }

export interface Fields {
  fieldInfoByField: FieldInfoByField;
  fieldInfoByEvent: FieldInfoByEvent;
}

// Blocks
// Blueprint: How we declare / register them.
export interface BlockBlueprint {
  name?: string;
  namespace: string;
  component?: React.ComponentType<any>;
  action?: Function;
  isGrader?: boolean;
  parser?: Function;
  staticKids?: Function;
  reducers?: Function[];
  fields?: Fields;
  getValue?: Function;
  extraDebug?: React.ComponentType<any>;
  description?: string;
}

// Blocks don't pass in the namespace; that's added by the partial
type BlockBlueprintReg = Omit<BlockBlueprint, "namespace">;

// Blueprints get processed into a block
export interface Block {
  component: React.ComponentType<any>;
  _isBlock: true;
  action?: Function;
  parser?: Function;
  staticKids?: Function;
  reducers: Function[];
  getValue?: Function;
  fields: FieldInfoByField;
  OLXName: OLXTag;
  description?: string;
  namespace: string;
  blueprint: BlockBlueprint;
}

export interface ComponentMap {
  [tag: string]: Block;
}

// A list of kids can have any of these; renderedCompiledChildren should handle all of these.
// TODO: These should probably all be of type kidEntry, and the current type should move under a different key.
export type BlueprintKidEntry =
  | { type: 'block'; id: OLXId; overrides?: Record<string, JSONValue> }
  | { type: 'text'; text: string }
  | { type: 'xml'; xml: string }
  | { type: 'cdata'; value: string }
  | { type: 'html'; tag: string; attributes: any; kids: BlueprintKidEntry[] }
  | { type: 'node'; rawParsed: any };

// TODO: Rename to indicate the type of node. This is a _dynamic_ node, as generated by render.
export interface NodeInfo {
  node: OlxJson;
  renderedKids: Record<OLXId, NodeInfo>;
  parent?: NodeInfo;
  blueprint: BlockBlueprint;
}

export interface PropType {
  id: string;
  kids: BlueprintKidEntry[];
  idMap: IdMap;
  blueprint: BlockBlueprint;
  fields: FieldInfoByField;
  nodeInfo: NodeInfo;
  componentMap: ComponentMap;
  idPrefix?: string;
  [key: string]: any;
}

export interface OlxJson {
  id: OLXId;
  tag: string;
  attributes?: Record<string, JSONValue>;
  provenance: Provenance;
  rawParsed: JSONValue;
  [key: string]: JSONValue | undefined;
}

export interface IdMap {
  [id: OLXId]: OlxJson;
}


export interface GraphNode {
  id: string;
  data: {
    label: string;
    attributes: Record<string, any>;
    tag: string;
    provenance?: any;
  };
  position: { x: number; y: number };
  type: string;
}

export interface GraphEdge {
  id: string;
  source: string;
  target: string;
}
