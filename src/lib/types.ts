// src/lib/types.ts
//
// Type definitions - central TypeScript types for Learning Observer architecture.
//
// Defines the core data structures that flow through the Learning Observer system:
// - Content types (OLX, provenance, errors)
// - Block system types (blueprints, components, fields)
// - State management types (Redux fields, scopes)
// - Storage types (providers, file metadata)
//
// TypeScript philosophy: We use types to avoid confusion on major interfaces
// and data structures, but generally don't type basic values (string, any, etc.).
// Focus is on documenting contracts between system components, not exhaustive typing.
//
import { z } from 'zod';
import { scopeNames } from './state/scopes';
import type { Store } from 'redux';

export type JSONValue =
  | string
  | number
  | boolean
  | null
  | JSONValue[]
  | { [key: string]: JSONValue };

// Content tier - computed from autogenerated flag
// - 'supported': Human-authored or reviewed content
// - 'bestEffort': Auto-generated or auto-translated, unreviewed
// Future: Computation can become more complex (e.g., autogenerated + reviewed by 2 people = supported)
export type ContentTier = 'supported' | 'bestEffort';

// OLX Content Loading Errors
export interface OLXLoadingError {
  type: 'parse_error' | 'duplicate_id' | 'file_error' | 'peg_error' | 'attribute_validation' | 'metadata_error';
  file: string;
  message: string;
  location?: {
    line?: number;
    column?: number;
    offset?: number;
  };
  technical?: any;
  stack?: any;
}

// Storage API: Grabbing OLX files from disk
export interface FileProvenance {
  type: 'file';
  path: string;
  [key: string]: any;
}

export interface GenericProvenance {
  type: string;
  path?: string;
  [key: string]: any;
}

/** URI identifying a source (e.g., "file://content/demos/foo.olx") */
export type ProvenanceURI = string;

/** OLX element tag name (e.g., "Vertical", "Sequential", "ChoiceInput") */
export type OLXTag = string & { __brand: 'OLXTag' };

// ID Types (Branded)
// See docs/README.md "IDs" section for documentation.
export type OlxReference = string & { __brand: 'OlxReference' };  // "/foo", "./foo", "foo"
export type OlxKey = OlxReference & { __resolved: true };         // idMap lookup key
export type IdPrefix = string & { __brand: 'IdPrefix' };          // scope prefix for Redux keys
export type ReduxStateKey = string & { __brand: 'ReduxStateKey' }; // state key with idPrefix
export type ReactKey = string & { __brand: 'ReactKey' };          // React reconciliation
export type HtmlId = string & { __brand: 'HtmlId' };              // DOM element ID

// Path Types (Branded) - Storage Layer Transformation Pipeline
// See docs/architecture/lofs.md for documentation.
//
// Transformation pipeline:
//   OlxRelativePath (as in XML) → LofsPath (storage layer)
//                                    ↓ (filesystem provider only)
//                                    → FileSystemPath (actual filesystem location)
//
export type OlxRelativePath = string & { __brand: 'OlxRelativePath' };  // "demos/foo.olx", "../bar/img.png"
export type LofsPath = string & { __brand: 'LofsPath' };                // "content/demos/foo.olx", "runtime/chat/msg.txt"
export type FileSystemPath = string & { __brand: 'FileSystemPath' };    // "./content/demos/foo.olx" or absolute path


/** Primary representation for provenance references */
export type Provenance = ProvenanceURI[];

/** Structured representation used in debug output */
export type ProvenanceStruct = FileProvenance | GenericProvenance;
export type ProvenanceEntry = ProvenanceURI | ProvenanceStruct;

// Fields API
export interface FieldInfo {
  type: 'field';
  name: string;
  event: string;
  scope: import('./state/scopes').Scope;
}

export interface FieldInfoByEvent { [event: string]: FieldInfo; }

/**
 * Field definitions for a block. Maps field names to FieldInfo.
 * Includes extend() for composing field sets.
 */
export type Fields = Record<string, FieldInfo> & {
  extend: (...more: Fields[]) => Fields;
};

/**
 * A valid JavaScript identifier (e.g., foo, getChoices, _private).
 * Must match /^[a-zA-Z_$][a-zA-Z0-9_$]*$/
 */
export type JavaScriptId = string;

/**
 * Block-local API functions. Keys must be valid JS identifiers
 * since they're called as locals.foo(). Values are any.
 */
export type LocalsAPI = Record<JavaScriptId, any>;

// Blocks
// Blueprint: How we declare / register them.

const ReduxFieldInfo = z.object({
  type: z.literal('field'),
  name: z.string(),
  event: z.string(),
  scope: z.enum(scopeNames),
}).strict();

// Fields schema: { fieldName: FieldInfo, ..., extend?: fn }
// Uses record for dynamic field names. The extend method is validated separately
// since Zod records require uniform value types.
export const ReduxFieldsReturn = z.record(
  z.union([ReduxFieldInfo, z.function()])
);

// === Schema ===
export const BlockBlueprintSchema = z.object({
  name: z.string().optional(),
  namespace: z.string().nonempty(),
  component: z.custom<React.ComponentType<any>>().optional(),
  action: z.function().optional(),
  isGrader: z.boolean().optional().default(false),
  isInput: z.boolean().optional().default(false),
  isMatch: z.boolean().optional().default(false),
  /**
   * Named slots for multi-input graders.
   * When provided, the framework resolves inputs to slots and passes an
   * inputDict object to the grader instead of an array.
   * Example: ['numerator', 'denominator'] for RatioGrader
   */
  slots: z.array(z.string()).optional(),
  /**
   * How to display the answer when "Show Answer" is clicked.
   * - 'per-input': Show next to each input (default)
   * - 'summary': Show once after all inputs
   * - 'custom': Grader handles display (e.g., MCQ highlights choices)
   * - 'none': No answer to show
   */
  answerDisplayMode: z.enum(['per-input', 'summary', 'custom', 'none']).optional(),
  /** Get display answers per slot for multi-input graders. */
  getDisplayAnswers: z.function().optional(),
  parser: z.function().optional(),
  staticKids: z.function().optional(),
  reducers: z.array(z.function()).optional(),
  fields: ReduxFieldsReturn.optional(),
  getValue: z.function().optional(),
  /**
   * Block-local API functions that expose the block's logic separately from its UI.
   *
   * While the React component (_Block.jsx) handles presentation, `locals` contains
   * the block's business logic as reusable functions. This separation enables:
   * - Server-side execution (grading, analytics) without React dependencies
   * - Cross-block communication (e.g., graders querying input metadata)
   * - Cleaner testing of logic independent of rendering
   *
   * Each function receives (props, state, id, ...args) when called through the API.
   * When passed to graders, these are pre-bound so graders just call fn(...args).
   *
   * Example for ChoiceInput:
   *   locals: {
   *     getChoices: (props, state, id) => {
   *       // Returns [{ id, tag, value }, ...] for Key/Distractor children
   *     }
   *   }
   *
   * A grader would then call: inputApi.getChoices() to get the choices.
   */
  locals: z.record(z.string(), z.any()).optional(),
  extraDebug: z.custom<React.ComponentType<any>>().optional(),
  description: z.string().optional(),
  /**
   * Marks this block as internal/system use only.
   * Internal blocks are hidden from the main documentation navigation
   * and grouped separately, as they're not intended for direct use by
   * course authors.
   */
  internal: z.boolean().optional(),
  /**
   * Optional category override for documentation grouping.
   * By default, blocks are grouped by their directory location (e.g., 'input', 'grading').
   * Set this to override the default categorization without moving the file.
   * Example: A grader block in the 'input' directory can set category: 'grading'
   * to appear under the Grading section in documentation.
   */
  category: z.string().optional(),
  /**
   * Controls whether this block type requires unique IDs in the content.
   *
   * - `true` (default): All instances must have unique IDs, enforces strict uniqueness
   * - `false`: Allows duplicate IDs, useful for content blocks like TextBlock/Markdown
   * - `'children'`: Recursively check if ANY child blocks require unique IDs. If any child
   *   requires uniqueness, this block will also require uniqueness. Useful for container
   *   blocks that may contain interactive content.
   * - `function`: Custom logic to determine uniqueness requirement at parse time.
   *   Receives context including parsed content, attributes, and current state.
   */
  requiresUniqueId: z.union([z.boolean(), z.literal('children'), z.function().returns(z.boolean())]).optional(),
  /**
   * Zod schema for validating block attributes at parse time and render time.
   * If defined, invalid attributes produce errors in parseOLX and DisplayError at render.
   */
  attributes: z.custom<z.ZodTypeAny>().optional(),
  /**
   * Semantic validation for attributes beyond what Zod schema can express.
   * Called after Zod parsing succeeds. Use for domain-specific validation like:
   * - NumericalGrader: answer must be a valid number/range
   * - StringGrader with regexp=true: answer must be a valid regex
   *
   * @param attrs - The parsed attributes (after Zod transforms)
   * @returns Array of error messages, or empty/undefined if valid
   */
  validateAttributes: z.function()
    .args(z.record(z.string(), z.any()))
    .returns(z.array(z.string()).optional())
    .optional(),
  /**
   * Declares that this block requires a parent grader in the hierarchy.
   * When true, render will inject `graderId` into props or show DisplayError if not found.
   */
  requiresGrader: z.boolean().optional(),
  /**
   * Returns the answer to display (may differ from grading answer).
   */
  getDisplayAnswer: z.function().optional(),
}).strict();

export type BlockBlueprint = z.infer<typeof BlockBlueprintSchema>;

/**
 * LoBlock - a Learning Observer block type (code, not content).
 *
 * Created from BlockBlueprint by factory.tsx. Stored in BlockRegistry.
 *
 * The block lifecycle:
 *   BlockBlueprint (what devs write) → LoBlock (processed) → OlxJson (instance) → OlxDomNode (rendered)
 */
export interface LoBlock {
  component: React.ComponentType<any>;
  _isBlock: true;
  action?: Function;
  parser?: Function;
  staticKids?: Function;
  reducers: Function[];
  getValue?: Function;
  locals?: Record<string, any>;
  fields: Fields;
  name?: string;  // Block name for selector matching
  OLXName: OLXTag;
  description?: string;
  namespace: string;
  isInput: boolean;
  isMatch: boolean;
  isGrader: boolean;
  /**
   * Marks this block as internal/system use only.
   * Internal blocks are hidden from the main documentation navigation.
   */
  internal?: boolean;
  /**
   * Optional category override for documentation grouping.
   * Overrides directory-based categorization without moving the file.
   */
  category?: string;
  /**
   * Controls whether this block type requires unique IDs in the content.
   *
   * - `true` (default): All instances must have unique IDs, enforces strict uniqueness
   * - `false`: Allows duplicate IDs, useful for content blocks like TextBlock/Markdown
   * - `'children'`: Recursively check if ANY child blocks require unique IDs. If any child
   *   requires uniqueness, this block will also require uniqueness. Useful for container
   *   blocks that may contain interactive content.
   * - `function`: Custom logic to determine uniqueness requirement at parse time.
   *   Receives context including parsed content, attributes, and current state.
   */
  requiresUniqueId?: boolean | 'children' | ((context: {
    id: string,
    attributes: Record<string, any>,
    tag: string,
    idMap: IdMap,
    provenance: Provenance,
    entry: any,
    children?: any[]
  }) => boolean);
  /**
   * Zod schema for validating block attributes at parse time and render time.
   */
  attributes?: z.ZodTypeAny;
  /**
   * Semantic validation for attributes beyond what Zod schema can express.
   * Returns array of error messages or undefined if valid.
   */
  validateAttributes?: (attrs: Record<string, any>) => string[] | undefined;
  /**
   * Declares that this block requires a parent grader in the hierarchy.
   */
  requiresGrader?: boolean;
  /**
   * Returns the answer to display (may differ from grading answer).
   */
  getDisplayAnswer?: (props: any) => any;
  /**
   * Named slots for multi-input graders.
   * When provided, the framework resolves inputs to slots and passes an
   * inputDict object to the grader instead of an array.
   */
  slots?: string[];
  /**
   * How to display the answer when "Show Answer" is clicked.
   * - 'per-input': Show next to each input (default)
   * - 'summary': Show once after all inputs
   * - 'custom': Grader handles display (MCQ highlights, etc.)
   * - 'none': No answer to show
   */
  answerDisplayMode?: 'per-input' | 'summary' | 'custom' | 'none';
  /**
   * Returns display answers per slot for multi-input graders.
   * Used when answerDisplayMode is 'per-input' with slots defined.
   */
  getDisplayAnswers?: (props: any) => Record<string, any>;

  // Documentation properties (added by generateBlockRegistry at build time)
  /** Path to the block's source file relative to project root */
  source?: string;
  /** Path to the block's README.md documentation file */
  readme?: string;
  /** Git status of the README file: 'committed' | 'modified' | 'untracked' */
  readmeGitStatus?: 'committed' | 'modified' | 'untracked';
  /** Array of example OLX files for this block */
  examples?: Array<{ path: string; gitStatus?: 'committed' | 'modified' | 'untracked' }>;
  /** Git status of the block source file: 'committed' | 'modified' | 'untracked' */
  gitStatus?: 'committed' | 'modified' | 'untracked';
}

export interface BlockRegistry {
  [tag: string]: LoBlock;  // Maps OLX tag names (e.g., "ChoiceInput", "Vertical") to block implementations
}

/** @deprecated Use BlockRegistry instead */
export type ComponentMap = BlockRegistry;

export type ComponentError = string | null;
export type ParseError = string | null | {
  type: 'missing_component' | 'missing_static_kids';
  tag: OLXTag;
  node: string;
  message: string;
};

/**
 * BlueprintKidEntry - A single child element in the parsed block structure.
 * Can represent blocks, text, XML, CDATA, or HTML elements.
 */
export type BlueprintKidEntry =
  | { type: 'block'; id: OlxReference; overrides?: Record<string, JSONValue> }
  | { type: 'text'; text: string }
  | { type: 'xml'; xml: string }
  | { type: 'cdata'; value: string }
  | { type: 'html'; tag: string; attributes: Record<string, JSONValue>; kids: BlueprintKidEntry[] };

/**
 * OlxDomNode - a node in the dynamic OLX DOM tree.
 *
 * Created at render time (not parse time). Has parent/child relationships
 * for traversal by the action system. Distinct from:
 * - OlxJson (static parsed content in idMap)
 * - React DOM (the actual browser rendering)
 */
export interface OlxDomNode {
  node: OlxJson;
  renderedKids: Record<OlxKey, OlxDomNode>;
  parent?: OlxDomNode;
  loBlock: LoBlock;
  sentinel?: string;  // 'root' for root node
  // runtime: LoBlockRuntimeContext;  // TODO: Uncomment and store at render time so actions can retrieve it
}

/** Selector function for filtering OlxDomNodes in DOM traversal */
export type OlxDomSelector = (node: OlxDomNode) => boolean;

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * INTERNATIONALIZATION TYPES: Locale, UserLocale, ContentVariant, RenderedVariant
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * These branded types prevent confusion between different semantic concepts in the
 * i18n pipeline. Each represents a distinct role:
 *
 * ┌─────────────────────────────────────────────────────────────────────────────┐
 * │ LOCALE - A single language code, extracted from variants                    │
 * ├─────────────────────────────────────────────────────────────────────────────┤
 * │ What: A BCP 47 language tag for a single language (no feature flags)        │
 * │ Examples: "en-Latn-US", "ar-Arab-SA", "pl-Latn-PL", "es-Latn-ES"           │
 * │ Source: Extracted from ContentVariants by stripping feature flags           │
 * │ Usage: Content selection, language switcher UI, user preferences            │
 * │ Current: Identical to ContentVariant at runtime (no feature flags yet)      │
 * │ Future: Feature variants like "en-Latn-US:audio-only" will be parsed to    │
 * │         extract just "en-Latn-US" via localeFromVariant()                  │
 * │                                                                              │
 * │ Helper: localeFromVariant(variant: ContentVariant) → Locale                │
 * │   - Current: No-op (variants are just locales)                             │
 * │   - Future: Parses compound variants, returns language part                │
 * └─────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────┐
 * │ USER LOCALE - What the user prefers to read                                │
 * ├─────────────────────────────────────────────────────────────────────────────┤
 * │ What: User's language preference/setting                                   │
 * │ Current: A single Locale (e.g., "en-Latn-US")                             │
 * │ Source: Browser language → Redux settings → author override (lang= attr)   │
 * │ Usage: Select content variant to render, configure UI language            │
 * │                                                                              │
 * │ FUTURE EVOLUTION:                                                           │
 * │ As platform matures, UserLocale will become more sophisticated:            │
 * │                                                                              │
 * │ Option A: Polyglot Users                                                   │
 * │   type UserLocale = {                                                      │
 * │     preferred: Locale[];  // [en-Latn-US, pl-Latn-PL, fr-Latn-FR]       │
 * │     fallback: Locale;                                                      │
 * │   }                                                                         │
 * │   Use case: Teachers in multilingual communities reading in 2-3 languages  │
 * │   Selection: Try each preferred locale; fall back if not available        │
 * │                                                                              │
 * │ Option B: Feature Preferences                                              │
 * │   type UserLocale = {                                                      │
 * │     locale: Locale;                                                        │
 * │     features: {                                                            │
 * │       audioEnabled: boolean;    // Prefer audio when available            │
 * │       highContrast: boolean;    // Prefer high-contrast visuals           │
 * │       fontSize: 'normal' | 'large' | 'xlarge';                          │
 * │     };                                                                      │
 * │   }                                                                         │
 * │   Use case: Accessibility preferences, low-bandwidth mode                 │
 * │   Selection: Match feature preferences alongside language                 │
 * │                                                                              │
 * │ Both: Combined                                                              │
 * │   type UserLocale = {                                                      │
 * │     preferred: Locale[];  // Polyglot support                            │
 * │     features: FeaturePreferences;  // Accessibility + context             │
 * │   }                                                                         │
 * └─────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────┐
 * │ CONTENT VARIANT - What's available in content                              │
 * ├─────────────────────────────────────────────────────────────────────────────┤
 * │ What: A key representing available language/feature combination in content │
 * │ Examples:                                                                   │
 * │   Current: "en-Latn-US", "ar-Arab-SA", "pl-Latn-PL"                      │
 * │   Future: "en-Latn-US", "en-Latn-US:audio-only", "en:low-bandwidth",     │
 * │           "ar-Arab-SA:vision-impaired", "*" (catch-all)                  │
 * │ Source: idMap keys (from file-level metadata in OLX)                     │
 * │ Storage: idMap[blockId][variant] = OlxJson                              │
 * │ Usage: Variant selection/matching, content storage structure             │
 * │                                                                              │
 * │ Structure: language[:feature][:feature]...                               │
 * │   - language: BCP 47 tag (e.g., "en-Latn-US")                           │
 * │   - feature: accessibility/context modifier (e.g., "audio-only")        │
 * │   - "*": Wildcard fallback matching any variant                         │
 * │                                                                              │
 * │ Selection Algorithm (getBestVariant):                                      │
 * │   1. Try exact UserLocale match                                           │
 * │   2. Try language + matching features                                     │
 * │   3. Try language only (discard feature preferences)                     │
 * │   4. Try language parent (en-Latn-US → en-Latn → en)                   │
 * │   5. Try wildcard "*"                                                    │
 * │   6. Error: no variant available                                         │
 * └─────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────┐
 * │ RENDERED VARIANT - The selected variant to render                          │
 * ├─────────────────────────────────────────────────────────────────────────────┤
 * │ What: A ContentVariant that has been selected via getBestVariant*         │
 * │ Usage: Marks that this variant has been "chosen" and is being rendered   │
 * │ Purpose: Prevents re-selection; enables caching and memoization         │
 * └─────────────────────────────────────────────────────────────────────────────┘
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * MIGRATION PATH FOR FUTURE FEATURE VARIANTS
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Phase 1 (Current):
 * - ContentVariant is just locale codes
 * - localeFromVariant() is a no-op
 * - All code treats variants and locales identically
 *
 * Phase 2 (Near Future):
 * - Add support for compound variants: "en-Latn-US:audio-only"
 * - localeFromVariant() parses and extracts language part
 * - LanguageSwitcher filters out non-language variants for UI
 * - Content storage unchanged (idMap[blockId][fullVariant] = OlxJson)
 *
 * Phase 3 (Longer Term):
 * - UserLocale evolves to support preferences/polyglot
 * - getBestVariant matches both language and feature preferences
 * - LanguageSwitcher shows language options with feature indicators
 * - SelectVariant selector becomes more sophisticated (feature filtering)
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/** A single language code, extracted from variants by stripping feature flags */
export type Locale = string & { readonly __locale: true };

/** What the user prefers to read (browser → Redux → author override) */
export type UserLocale = string & { readonly __userLocale: true };

/** A language/accessibility/context variant available for content (e.g., "ar-Arab-SA", "en:audio-only") */
export type ContentVariant = string & { readonly __variant: true };

/** The variant we actually render - a ContentVariant selected via getBestVariant* functions */
export type RenderedVariant = ContentVariant & { readonly __rendered: true };

/**
 * LocaleContext - language and text direction configuration.
 *
 * Enables i18n throughout the platform. For now, `dir` comes from Redux settings.
 * Future: derive `dir` from Intl.Locale.getTextInfo() when browser support is universal.
 */
export interface LocaleContext {
  code: UserLocale;  // BCP 47 locale code: 'en-Latn-US', 'zh-Hans-CN', 'ar-Arab-SA', 'pl-Latn-PL', 'tr-TR'
  dir: 'ltr' | 'rtl';  // Text direction from Redux settings
}

/**
 * LoBlockRuntimeContext - runtime configuration that flows through the component tree.
 *
 * Contains system-wide runtime properties that may change based on context:
 * - blockRegistry: Registry of all available block blueprints
 * - store: Redux store (may be historical during replay mode)
 * - logEvent: Event logging function (no-op during replay)
 * - sideEffectFree: True during replay - disables fetches and logging
 * - olxJsonSources: Priority-ordered list of Redux source names for OlxJson lookup
 * - idPrefix: Scope prefix for Redux state keys (changes at list boundaries)
 *
 * This is bundled into RuntimeProps to enable easier addition of new runtime properties
 * (like locale) without full prop-threading updates.
 */
export interface LoBlockRuntimeContext {
  blockRegistry: BlockRegistry;
  store: Store;
  logEvent: (event: string, payload: any) => void;  // Event logging - no-op during replay
  sideEffectFree: boolean;  // True during replay - disables fetches, event logging, etc.
  olxJsonSources?: string[];  // Redux source names in priority order for OlxJson lookup
  idPrefix?: IdPrefix;  // Scope prefix for Redux state (changes at list boundaries)
  locale: LocaleContext;  // Language and text direction
}

/**
 * RuntimeProps - the context bag passed through the system.
 *
 * This is a hybrid of three things (pragmatic compromise for React):
 * 1. Opaque context (nodeInfo, runtime) - thread through, don't inspect
 * 2. Block machinery (loBlock, fields, locals) - framework injects these
 * 3. OLX attributes - flow in via [key: string]: any
 *
 * Most functions just pass props through without inspecting. Blocks destructure
 * only what they need (usually just attributes and fields).
 */
export interface RuntimeProps {
  // This block's identity and content
  id: string;
  kids: BlueprintKidEntry[];

  // Opaque context - thread through
  nodeInfo: OlxDomNode;
  runtime: LoBlockRuntimeContext;  // Bundled runtime context (required)

  // Block machinery - framework injects these
  loBlock: LoBlock;
  fields: Fields;
  locals: LocalsAPI;  // {} if none, not undefined

  // OLX attributes flow in here
  [key: string]: any;
}

/**
 * OlxJson - Parsed content for a single block in a specific variant.
 *
 * Represents the structure and metadata for a block at render time.
 * Each block can have multiple OlxJson entries in idMap[blockId] - one per ContentVariant.
 *
 * Metadata cascades down from file-level through element hierarchy:
 * 1. File-level metadata (from YAML comment at top of OLX file)
 * 2. Parent element metadata (inherited by children unless overridden)
 * 3. Element-level metadata (from preceding comment or element attributes)
 *
 * Note: The `lang` field represents the language/variant of THIS specific OlxJson entry.
 * It's separate from the ContentVariant key (idMap[id][variant]) which may evolve to
 * include feature flags (e.g., "en-Latn-US:audio-only"). The `lang` field stays as a
 * simple BCP 47 code for now, identifying which language variant this entry represents.
 */
export interface OlxJson {
  id: OlxKey;
  tag: OLXTag;
  attributes: Record<string, JSONValue>;  // Always present, defaults to {} in parsing
  provenance: Provenance;

  // Optional metadata (from YAML frontmatter or parsed attributes)
  /** Brief description of this content block (for search, activity cards, etc.) */
  description?: string;
  /** Content category for filtering/organization (e.g., "psychology", "writing", "demo") */
  category?: string;
  /** BCP 47 language tag identifying which language/variant this OlxJson represents (e.g., 'en-Latn-US', 'ar-Arab-SA') */
  lang?: string;
  /** Whether this content was auto-generated (true) or human-authored (false/undefined) */
  autogenerated?: boolean;
  /** Source file for auto-generated content (useful for tracking translation origins) */
  source_file?: string;
  /** Version hash of source for detecting when re-translation is needed */
  source_version?: string;

  [key: string]: JSONValue | undefined;
}

/**
 * IdMap - Content index mapping block IDs to their available variants.
 *
 * Structure: Maps each block ID to a variant map, where each variant is a
 * different version of that block (language, accessibility, context, etc.).
 *
 * Enables multi-dimensional content variants:
 * - Language: "en-Latn-US", "ar-Arab-SA", "pl-Latn-PL"
 * - Feature variants (future): "en-Latn-US:audio-only", "en:low-bandwidth"
 * - Wildcard fallback: "*" (matches any variant if no better match)
 *
 * CURRENT STATE:
 * - Keys are language codes (BCP 47): "en-Latn-US", "ar-Arab-SA"
 * - One variant per block per language
 *
 * FUTURE STATE:
 * - Keys are compound variants: "en-Latn-US:audio-only", "ar-Arab-SA:vision-impaired"
 * - Multiple variants per language (language + feature combinations)
 * - Structured variant matching with BCP 47 language hierarchy fallback
 *
 * EXAMPLE:
 * ```
 * idMap = {
 *   "my-problem": {
 *     "en-Latn-US": OlxJson { id, tag, attributes, ... },
 *     "ar-Arab-SA": OlxJson { id, tag, attributes, ... },
 *     "en-Latn-US:audio-only": OlxJson { ... },  // Future
 *     "*": OlxJson { ... }  // Wildcard fallback (Future)
 *   },
 *   "another-block": {
 *     "en-Latn-US": OlxJson { ... },
 *     ...
 *   }
 * }
 * ```
 */
export interface IdMap {
  [id: OlxKey]: {
    [variant: ContentVariant]: OlxJson;
  };
}

/**
 * GraphNode - A node in the content dependency graph.
 * Represents a single block and its metadata.
 */
export interface GraphNode {
  id: OlxKey;  // Block ID that this node represents
  data: {
    label: string;
    attributes: Record<string, string>;
    tag: OLXTag;
    provenance?: any;
  };
  position: { x: number; y: number };
  type: string;
}

/**
 * GraphEdge - An edge in the content dependency graph.
 * Represents a reference from one block to another.
 */
export interface GraphEdge {
  id: string;  // Edge ID (graph-specific, not a block ID)
  source: OlxKey;  // Source block ID
  target: OlxKey;  // Target block ID
}
