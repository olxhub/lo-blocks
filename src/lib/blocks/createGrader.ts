// src/lib/blocks/createGrader.ts
//
// Factory function for creating grader blocks with minimal boilerplate.
//
// When you call createGrader({ base: 'String', ... }), it creates TWO blocks:
// - StringGrader: A full grader block that connects to inputs
// - StringMatch: A matching rule for use inside RulesGrader
//
// The author only writes the match function and attributes once - the grader
// is auto-generated by mapping MatchResult states to CORRECTNESS values.
//
// Usage:
//   export default createGrader({
//     base: 'String',
//     description: 'Grades text answers',
//     match: stringMatch,  // Pure predicate returning MatchResult
//     attributes: {
//       answer: z.string({ required_error: 'answer is required' }),
//       regexp: strictBoolean,
//       ignoreCase: strictBoolean,
//     },
//   });
//
// The `match` function is automatically registered in the state language DSL,
// enabling expressions like: stringMatch(@answer.value, 'Paris', { ignoreCase: true })
//
import React from 'react';
import { z } from 'zod';
import { core } from './namespaces';
import * as parsers from '@/lib/content/parsers';
import { grader } from './actions';
import { graderAttributes, baseAttributes } from './attributeSchemas';
import _Noop from '@/components/blocks/layout/_Noop';
import { registerDSLFunction } from '@/lib/stateLanguage/functions';
import { CORRECTNESS } from './correctness';
import type { MatchFunction, MatchResult } from './matchResult';
import type { RuntimeProps, LocalsAPI } from '@/lib/types';

// Registry of Match blocks created by createGrader
// blockRegistry.ts will merge these in
export const MATCH_BLOCKS = {};

// Shared attributes for rules (score, feedback, feedbackBlock)
const RULE_ATTRIBUTES = {
  score: z.coerce.number().min(0).max(1).optional(),
  feedback: z.string().optional(),
  feedbackBlock: z.string().optional(),
};

/**
 * Map MatchResult state to CORRECTNESS value.
 */
const MATCH_TO_CORRECTNESS: Record<MatchResult['state'], string> = {
  match: CORRECTNESS.CORRECT,
  no_match: CORRECTNESS.INCORRECT,
  invalid: CORRECTNESS.INVALID,
  unsubmitted: CORRECTNESS.UNSUBMITTED,
};

/**
 * Create a grader function from a match function.
 *
 * The grader extracts the answer and options from props, calls the match
 * function, and maps the MatchResult state to a CORRECTNESS value.
 */
function graderFromMatch(matchFn: MatchFunction): (props: RuntimeProps, params: { input?: any }) => { correct: string; message: string } {
  return (props, { input }) => {
    // Extract options from props (everything except answer and standard grader attrs)
    const { answer, target, displayAnswer, ...options } = props;
    const result = matchFn(input, answer, options);
    return {
      correct: MATCH_TO_CORRECTNESS[result.state],
      message: result.message ?? '',
    };
  };
}

/**
 * Create a grader block (and its Match variant) with minimal boilerplate.
 *
 * @param {Object} config
 * @param {string} config.base - Base name (e.g., 'String' creates StringGrader + StringMatch)
 * @param {string} config.description - Documentation description
 * @param {Function} config.match - Pure match function: (input, pattern, options?) => MatchResult
 * @param {Object} config.attributes - Zod schema fields specific to this grader
 * @param {Function} [config.getDisplayAnswer] - Optional, returns answer for "Show Answer"
 * @param {Object} [config.locals] - Optional locals API functions
 *
 * @returns {Block} The Grader block (Match variant is auto-registered)
 */

// Re-export for backwards compatibility
export type { MatchFunction } from './matchResult';

interface CreateGraderConfig {
  base: string;
  description: string;
  /**
   * Pure match function returning MatchResult. When provided:
   * - Registered in the DSL as `${base.toLowerCase()}Match` (e.g., 'stringMatch')
   * - Used by RulesGrader's Match block for predicate matching
   * - Auto-generates the grader function by mapping MatchResult â†’ CORRECTNESS
   *
   * The function signature: (input, pattern, options?) => MatchResult
   *
   * Note: For graders that don't fit the match pattern (e.g., CustomGrader,
   * multi-input graders), omit this and provide a custom grader function instead.
   */
  match?: MatchFunction;
  /**
   * Custom grader function. If match is provided and grader is not, the grader
   * is auto-generated from match. Required if match is not provided.
   */
  grader?: (props: RuntimeProps, params: { input?: any; inputs?: any[] }) => { correct: any; message: any };
  attributes?: Record<string, any>;
  /**
   * Semantic validation for attributes at parse time.
   * Called after Zod parsing succeeds. Returns array of error messages or empty/undefined if valid.
   * Use for domain-specific validation like:
   * - answer must be a valid number/range
   * - regexp pattern must be valid
   * - tolerance must be a valid number or percentage
   */
  validateAttributes?: (attrs: Record<string, any>) => string[] | undefined;
  getDisplayAnswer?: (props: RuntimeProps) => any;
  locals?: LocalsAPI;
  /** If false, don't infer inputs from children (use explicit target). Default: true */
  infer?: boolean;
  /** If false, don't create a Match block variant. Default: true */
  createMatch?: boolean;
  /** Custom component to render. Default: _Noop (renders children). Use _Hidden to hide children. */
  component?: React.ComponentType<any>;
  /** Custom parser for children. Default: parsers.blocks.allowHTML(). Use parsers.text() for code content. */
  parser?: { parser: (ctx: any) => Promise<any>; staticKids?: (entry: any) => any[] };
}

export function createGrader({
  base,
  description,
  match: matchFn,
  grader: customGraderFn,
  attributes = {},
  validateAttributes,
  getDisplayAnswer,
  locals,
  infer = true,
  createMatch = true,
  component = _Noop,
  parser,
}: CreateGraderConfig) {
  const graderName = `${base}Grader`;
  const matchName = `${base}Match`;

  // Register a DSL wrapper that returns boolean for use in conditions
  // e.g., stringMatch(@answer.value, "Paris") returns true/false
  // Only if match function is provided
  if (matchFn) {
    const dslFunctionName = `${base.charAt(0).toLowerCase()}${base.slice(1)}Match`;
    const dslWrapper = (input: any, pattern: any, options?: Record<string, any>) => {
      const result = matchFn(input, pattern, options);
      return result.state === 'match';
    };
    registerDSLFunction(dslFunctionName, dslWrapper);
  }

  // Auto-generate grader from match function, or use custom grader if provided
  // One of match or grader must be provided
  const graderFn = customGraderFn ?? (matchFn ? graderFromMatch(matchFn) : undefined);
  if (!graderFn) {
    throw new Error(`createGrader(${base}): Either match or grader must be provided`);
  }

  // Create the full Grader block (connects to inputs, grades them)
  const graderBlock = core({
    ...(parser ?? parsers.blocks.allowHTML()),
    ...grader({ grader: graderFn, infer }),
    name: graderName,
    description,
    category: 'grading',
    component,
    attributes: graderAttributes.extend(attributes),
    validateAttributes,
    getDisplayAnswer: getDisplayAnswer ?? ((props: RuntimeProps) => props.displayAnswer ?? props.answer),
  }, locals);

  // Create the Match block (a rule for use inside RulesGrader)
  // Match blocks don't connect to inputs - they just define matching logic
  // Some graders (like CodeGrader) don't need a Match variant
  if (createMatch) {
    const matchBlock = core({
      ...parsers.blocks(),  // No allowHTML needed for simple rules
      name: matchName,
      description: `Matching rule for ${base} patterns, used inside RulesGrader`,
      category: 'grading',
      component: _Noop,
      internal: true,  // Hide from main docs - it's used inside RulesGrader
      isMatch: true,   // Mark as a Match block (used by RulesGrader)
      // Use strict() to catch attribute typos like bob="doo"
      attributes: baseAttributes.extend({
        ...RULE_ATTRIBUTES,
        ...attributes,
      }).strict(),
      // Store the matching function so RulesGrader can call it
      locals: {
        match: graderFn,
        ...(locals || {}),
      },
    });

    // Register the Match block for blockRegistry to pick up
    MATCH_BLOCKS[matchName] = matchBlock;
  }

  // Return only the Grader block (the default export)
  return graderBlock;
}

export default createGrader;
