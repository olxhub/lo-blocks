// src/app/api/translate/route.ts
//
// *** PROTOTYPE — NOT PRODUCTION-READY ***
//
// Server-side translation endpoint. Receives a blockId + target locale,
// finds the source OLX file, translates via LLM, saves to LOFS,
// re-syncs content, and returns the updated idMap for affected blocks.
//
// File naming convention:
//   demos/algebra101lesson.olx → demos/algebra101lesson/ar-Arab-SA.auto.olx
//   The .auto.olx extension marks autogenerated translations (gitignored).
//   Human-reviewed translations would use plain .olx in the same subdirectory.
//
// Known gaps and missing functionality:
//
// 1. NO QUALITY CONTROL
//    - LLM output is saved directly with no validation
//    - Missing: parse translated XML and compare IDs/structure against source
//    - Missing: detect dropped elements, renamed IDs, broken nesting
//    - Missing: validate that the output is well-formed XML at all
//    - Bad translations are silently saved and served to users
//
// 2. INCOMPLETE ASSET HANDLING
//    - Translated files live in subdirectories (e.g., demos/foo/ar.olx)
//      but relative asset paths (src="file.chatpeg", src="image.png")
//      resolve relative to the translated file, not the source
//    - Associated auxiliary files (.chatpeg, .md, images) are not translated
//    - See docs/architecture/assets.md for the full picture
//
// 3. FRAGILE METADATA HANDLING
//    - File-level frontmatter: LLM is prompted to translate description/title
//      and preserve category, but there's no verification. Category override
//      from source at parse time (defense-in-depth) is not yet implemented.
//    - Child metadata comments (YAML above inner elements): the LLM is asked
//      to preserve them, but may mangle, drop, or mistranslate them
//    - Leading comment extraction from LLM output uses string matching, not
//      the XML parser. Acceptable for LLM output (simple, predictable) but
//      not for arbitrary OLX content.
//
// 4. NO INCREMENTAL RE-TRANSLATION
//    - If the source file changes, existing translations become stale
//    - source_version hash is stored but never checked
//    - No mechanism to detect or trigger re-translation of outdated files
//
// 5. NO HUMAN REVIEW WORKFLOW
//    - generated.method='machineTranslated' marks content, but there's
//      no UI or workflow for human review, approval, or correction
//    - No way to promote a reviewed translation to "verified" status
//
// 6. SINGLE-FILE SCOPE
//    - Translates one OLX file at a time
//    - Cross-file references (<Use ref="...">) may point to untranslated blocks
//    - No batch translation or dependency-aware translation ordering
//
// 7. NO RTL / TYPOGRAPHIC ADAPTATION
//    - The LLM handles text translation but not layout concerns
//    - RTL languages may need dir="rtl" attributes, CSS adjustments, etc.
//    - No handling of locale-specific number formats, date formats, etc.
//
// 8. CONCURRENCY LIMITATIONS
//    - In-flight dedup is per-process (module-level Map), not cross-process
//    - Multiple server instances could duplicate translation work
//    - No persistent queue or job system for translation requests
//

import { NextResponse } from 'next/server';
import path from 'path';
import fs from 'fs/promises';
import { FileStorageProvider } from '@/lib/lofs/providers/file';
import { syncContentFromStorage, getSourceFile, getBlocksForFiles, getBlockVariant, getOriginalVariant } from '@/lib/content/syncContentFromStorage';
import { callLLM } from '@/lib/llm/serverCall';
import { getProvider } from '@/lib/llm/provider';
import { getLanguageLabel } from '@/lib/i18n/languages';
import { hashContent } from '@/lib/util';
import type { OlxKey, ContentVariant, ProvenanceURI, OlxRelativePath, SafeRelativePath } from '@/lib/types';
import { toOlxRelativePath } from '@/lib/lofs/types';
import yaml from 'js-yaml';

const contentDir = process.env.OLX_CONTENT_DIR || './content';
const provider = new FileStorageProvider(contentDir);

// Server-side dedup: concurrent requests for same file+locale await the same promise.
// Entries are cleaned up in the route handler's finally block. The timeout below
// prevents a hung LLM call from blocking that key permanently.
const inFlightTranslations = new Map<string, Promise<any>>();
const TRANSLATION_TIMEOUT_MS = 600_000; // 10 minutes

type TranslationResult = { ok: boolean; idMap?: any; error?: string };

// =============================================================================
// String Helpers
// =============================================================================

/** Strip markdown code fences that LLMs sometimes add.

    We should confirm this is needed later. It is likely just a
    property of a dev LLM.
 */
function stripCodeFences(text: string): string {
  let result = text.trim();
  if (result.startsWith('```')) {
    const firstNewline = result.indexOf('\n');
    if (firstNewline !== -1) {
      result = result.slice(firstNewline + 1);
    }
    if (result.endsWith('```')) {
      result = result.slice(0, -3).trimEnd();
    }
  }
  return result;
}

/** Extract leading XML comments and body from content.
 *  Returns comment texts (for metadata extraction) and the body (root element onward).
 *  Comments inside the document (child metadata, etc.) are preserved in body. */
function extractLeadingComments(content: string): { comments: string[]; body: string } {
  const comments: string[] = [];
  let s = content;
  while (true) {
    s = s.trimStart();
    if (!s.startsWith('<!--')) break;
    const endIdx = s.indexOf('-->');
    if (endIdx === -1) break;
    comments.push(s.slice(4, endIdx).trim());
    s = s.slice(endIdx + 3);
  }
  return { comments, body: s.trimStart() };
}

/** Try to parse YAML frontmatter from extracted comment texts.
 *  Looks for a comment with --- delimiters and parses the YAML inside. */
function parseMetadataFromComments(comments: string[]): Record<string, any> {
  for (const text of comments) {
    const match = text.match(/^---\s*\n([\s\S]*?)\n\s*---\s*$/);
    if (!match) continue;
    try {
      return (yaml.load(match[1]) as Record<string, any>) || {};
    } catch {
      continue;
    }
  }
  return {};
}

/** Build YAML frontmatter comment from a metadata object. */
function buildFrontmatter(metadata: Record<string, any>): string {
  const body = yaml.dump(metadata, { lineWidth: -1 }).trimEnd();
  return `<!--\n---\n${body}\n---\n-->`;
}

// =============================================================================
// Path Helpers
// =============================================================================

// demos/algebra101lesson.olx → demos/algebra101lesson/ar-Arab-SA.auto.olx
function computeTranslationPath(sourceRelPath: OlxRelativePath, targetLocale: ContentVariant): OlxRelativePath {
  const ext = path.extname(sourceRelPath);
  const base = sourceRelPath.slice(0, -ext.length);
  // Canonical path with no ".." — safe to brand directly
  return `${base}/${targetLocale}.auto${ext}` as OlxRelativePath;
}

/** Convert a file:// provenance URI to a content-relative path.
 *  toRelativePath strips the file:// prefix and validates the path
 *  is within the provider's baseDir — the result is always a valid
 *  OlxRelativePath (relative, no escape). */
function uriToRelPath(fileUri: ProvenanceURI): OlxRelativePath {
  return provider.toRelativePath(fileUri) as OlxRelativePath;
}

// =============================================================================
// Translation Pipeline
// =============================================================================

/** If the source is a translation, follow source_file back to the original.
 *  Always translate from human-authored source to avoid quality degradation.
 *  Returns both the resolved file URI and the effective source locale (from the
 *  original, not the intermediate translation) so the LLM prompt matches the
 *  actual source content. */
function resolveOriginalSource(
  sourceFileUri: ProvenanceURI, blockId: OlxKey, sourceLocale: ContentVariant
): { fileUri: ProvenanceURI; locale: ContentVariant } {
  const sourceVariant = getBlockVariant(blockId, sourceLocale);
  if (sourceVariant?.generated?.method !== 'machineTranslated' || !sourceVariant?.generated?.source_file) {
    return { fileUri: sourceFileUri, locale: sourceLocale };
  }
  const originalFileName = sourceVariant.generated.source_file;
  const sourceRelPath = uriToRelPath(sourceFileUri);
  // Navigate from translation subdir back to source: demos/foo/fr.auto.olx → demos/originalFileName
  const originalRelPath = path.join(path.dirname(path.dirname(sourceRelPath)), originalFileName) as OlxRelativePath;

  // Derive the actual language from the human-authored original so the LLM
  // prompt says "translate from English" when the source content is English,
  // even if the request came through a French intermediate translation.
  const original = getOriginalVariant(blockId);
  const effectiveLocale = (original?.lang as ContentVariant) || sourceLocale;

  // originalRelPath is derived from canonical paths (no ..) — safe to treat as SafeRelativePath
  return { fileUri: provider.toProvenanceURI(originalRelPath as SafeRelativePath), locale: effectiveLocale };
}

/** Check if a translation already exists. If so, re-sync and return its blocks. */
async function checkExistingTranslation(
  targetRelPath: OlxRelativePath,
  sourceFileUri: ProvenanceURI
): Promise<TranslationResult | null> {
  try {
    await provider.read(targetRelPath);
  } catch {
    return null; // Doesn't exist — proceed with translation
  }
  await syncContentFromStorage(provider);
  return { ok: true, idMap: getBlocksForFiles(sourceFileUri, provider.toProvenanceURI(targetRelPath as SafeRelativePath)) };
}

/** Build the LLM prompt for OLX translation. */
function buildTranslationPrompt(
  sourceLocale: ContentVariant,
  targetLocale: ContentVariant
): { role: string; content: string }[] {
  const systemPrompt = `You are a translator for educational content in OLX (XML) format.

Rules for XML content:
- Translate ALL human-readable text (text between tags, attribute values like "title", "label", "placeholder", "description")
- PRESERVE all XML tags, tag names, id attributes, and structural attributes unchanged
- Do NOT translate: id values, ref values, tag names, CSS classes, LaTeX formulas, code blocks
- Maintain the exact same XML structure and nesting
- For mathematical content, preserve formulas but translate surrounding text
- Use natural, culturally appropriate phrasing

Rules for YAML metadata comments (<!-- --- ... --- -->):
- Translate "description" and "title" values
- Do NOT translate "category" — keep it unchanged
- Set "lang" to "${targetLocale}"
- Keep all other fields unchanged
- Preserve the exact <!-- --- ... --- --> comment format

Output ONLY the translated content — no explanations, no markdown fencing, no commentary.`;

  return [{ role: 'system', content: systemPrompt }];
}

/** Call the LLM to translate OLX content. */
async function translateWithLLM(
  sourceContent: string,
  sourceLocale: ContentVariant,
  targetLocale: ContentVariant
): Promise<string> {
  const sourceLanguageName = getLanguageLabel(sourceLocale, 'en', 'name');
  const targetLanguageName = getLanguageLabel(targetLocale, 'en', 'name');
  const messages = [
    ...buildTranslationPrompt(sourceLocale, targetLocale),
    { role: 'user', content: `Translate the following OLX content from ${sourceLanguageName} to ${targetLanguageName}:\n\n${sourceContent}` },
  ];
  const raw = await callLLM(messages);
  const cleaned = stripCodeFences(raw);
  if (!cleaned.trim()) {
    throw new Error('LLM returned empty translation');
  }
  return cleaned;
}

/** Build the translated file: merge LLM-translated metadata with provenance fields. */
async function buildTranslatedFile(
  llmOutput: string,
  sourceContent: string,
  effectiveRelPath: OlxRelativePath,
  targetLocale: ContentVariant,
  blockId: OlxKey
): Promise<string> {
  const { comments, body } = extractLeadingComments(llmOutput);
  const llmMeta = parseMetadataFromComments(comments);
  const originalVariant = getOriginalVariant(blockId);

  const translatedMeta: Record<string, any> = {
    ...llmMeta,
    ...(originalVariant?.category && { category: originalVariant.category }),
    lang: targetLocale,
    generated: {
      method: 'machineTranslated',
      source_file: path.basename(effectiveRelPath),
      source_version: await hashContent(sourceContent),
    },
  };

  return `${buildFrontmatter(translatedMeta)}\n${body}`;
}

/** Write a translated file to storage, creating parent directories as needed. */
async function writeTranslatedFile(targetRelPath: OlxRelativePath, fileContent: string): Promise<void> {
  const fullTargetPath = path.resolve(contentDir, targetRelPath);
  await fs.mkdir(path.dirname(fullTargetPath), { recursive: true });
  await provider.write(targetRelPath, fileContent);
}

// =============================================================================
// Main Entry Point
// =============================================================================

async function doTranslation(
  blockId: OlxKey,
  sourceFileUri: ProvenanceURI,
  targetLocale: ContentVariant,
  sourceLocale: ContentVariant
): Promise<TranslationResult> {
  // Resolve to the human-authored original (skip intermediate translations)
  const { fileUri: effectiveFileUri, locale: effectiveSourceLocale } =
    resolveOriginalSource(sourceFileUri, blockId, sourceLocale);
  const effectiveRelPath = uriToRelPath(effectiveFileUri);

  // Read source file content
  let sourceContent: string;
  try {
    sourceContent = (await provider.read(effectiveRelPath)).content;
  } catch (err: any) {
    return { ok: false, error: `Failed to read source file "${effectiveRelPath}": ${err.message}` };
  }

  // Return early if translation already exists
  const targetRelPath = computeTranslationPath(effectiveRelPath, targetLocale);
  const existing = await checkExistingTranslation(targetRelPath, sourceFileUri);
  if (existing) return existing;

  // Translate via LLM
  let llmOutput: string;
  try {
    llmOutput = await translateWithLLM(sourceContent, effectiveSourceLocale, targetLocale);
  } catch (err: any) {
    return { ok: false, error: `LLM translation failed: ${err.message}` };
  }

  // Build and write translated file
  const fileContent = await buildTranslatedFile(llmOutput, sourceContent, effectiveRelPath, targetLocale, blockId);
  try {
    await writeTranslatedFile(targetRelPath, fileContent);
  } catch (err: any) {
    return { ok: false, error: `Failed to write translation: ${err.message}` };
  }

  // Re-sync and return blocks from both source and translated files
  await syncContentFromStorage(provider);
  return { ok: true, idMap: getBlocksForFiles(sourceFileUri, provider.toProvenanceURI(targetRelPath as SafeRelativePath)) };
}

// =============================================================================
// Route Handler
// =============================================================================

export async function POST(request: Request) {
  try {
    const body = await request.json();

    if (!body.blockId || !body.targetLocale || !body.sourceLocale) {
      return NextResponse.json(
        { ok: false, error: 'Missing required fields: blockId, targetLocale, sourceLocale' },
        { status: 400 }
      );
    }

    // Validate locale format (BCP 47: alphanumeric segments separated by hyphens)
    //
    // Paths should be validated by the storage provider before write, but this is
    // part of defense-in-depth. It will need to be expanded when variants expand
    // beyond locale.
    const bcp47Re = /^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*$/;
    if (!bcp47Re.test(body.targetLocale) || !bcp47Re.test(body.sourceLocale)) {
      return NextResponse.json(
        { ok: false, error: 'Invalid locale format' },
        { status: 400 }
      );
    }

    // Cast after validation — branded types prevent accidental string confusion
    const blockId = body.blockId as OlxKey;
    const targetLocale = body.targetLocale as ContentVariant;
    const sourceLocale = body.sourceLocale as ContentVariant;

    // Stub mode: no real translation available
    if (getProvider().provider === 'stub') {
      return NextResponse.json(
        { ok: false, error: 'LLM is in stub mode — no real translation available' }
      );
    }

    // Ensure content store is hydrated (cold start / new serverless instance)
    await syncContentFromStorage(provider);

    // Look up source file from blockId + sourceLocale
    const sourceFileUri = getSourceFile(blockId, sourceLocale);
    if (!sourceFileUri) {
      return NextResponse.json(
        { ok: false, error: `Block "${blockId}" not found for locale "${sourceLocale}"` },
        { status: 404 }
      );
    }

    // Dedup: if same file+locale is already in flight, await that instead
    const dedupeKey = `${sourceFileUri}::${targetLocale}`;
    if (inFlightTranslations.has(dedupeKey)) {
      const result = await inFlightTranslations.get(dedupeKey);
      return NextResponse.json(result, result.ok ? undefined : { status: 500 });
    }

    const promise = doTranslation(blockId, sourceFileUri, targetLocale, sourceLocale);
    const timedPromise = Promise.race([
      promise,
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Translation timed out')), TRANSLATION_TIMEOUT_MS)
      ),
    ]);
    inFlightTranslations.set(dedupeKey, timedPromise);

    try {
      const result = await timedPromise;
      if (!result.ok) {
        return NextResponse.json(result, { status: 500 });
      }
      return NextResponse.json(result);
    } finally {
      inFlightTranslations.delete(dedupeKey);
    }
  } catch (error: any) {
    console.error('[/api/translate] Error:', error);
    return NextResponse.json(
      { ok: false, error: error.message || 'Unknown error' },
      { status: 500 }
    );
  }
}
