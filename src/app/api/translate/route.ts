// src/app/api/translate/route.ts
//
// Server-side translation endpoint. Receives a blockId + target locale,
// finds the source OLX file, translates via LLM, saves to LOFS,
// re-syncs content, and returns the updated idMap for affected blocks.
//
// File naming convention:
//   demos/algebra101lesson.olx → demos/algebra101lesson/ar-Arab-SA.olx
//

import { NextResponse } from 'next/server';
import path from 'path';
import { FileStorageProvider } from '@/lib/lofs/providers/file';
import { syncContentFromStorage, getSourceFile, getBlocksForFiles } from '@/lib/content/syncContentFromStorage';
import { callLLM } from '@/lib/llm/serverCall';
import { getProvider } from '@/lib/llm/provider';
import { getLanguageLabel } from '@/lib/i18n/languages';

const contentDir = process.env.OLX_CONTENT_DIR || './content';
const provider = new FileStorageProvider(contentDir);

// Server-side dedup: concurrent requests for same file+locale await the same promise
const inFlightTranslations = new Map<string, Promise<any>>();

// =============================================================================
// Translation Pipeline
// =============================================================================

function hashContent(content: string): string {
  const crypto = require('crypto');
  return crypto.createHash('sha256').update(content).digest('hex').slice(0, 8);
}

/** Strip markdown code fences that LLMs sometimes add */
function stripCodeFences(text: string): string {
  let result = text.trim();
  if (result.startsWith('```')) {
    const firstNewline = result.indexOf('\n');
    if (firstNewline !== -1) {
      result = result.slice(firstNewline + 1);
    }
    if (result.endsWith('```')) {
      result = result.slice(0, -3).trimEnd();
    }
  }
  return result;
}

// demos/algebra101lesson.olx → demos/algebra101lesson/ar-Arab-SA.olx
function computeTranslationPath(sourceRelPath: string, targetLocale: string): string {
  const ext = path.extname(sourceRelPath);
  const base = sourceRelPath.slice(0, -ext.length);
  return `${base}/${targetLocale}${ext}`;
}

function buildFrontmatter(targetLocale: string, sourceFileName: string, sourceVersion: string): string {
  return `<!--
---
lang: ${targetLocale}
autogenerated: true
source_file: ${sourceFileName}
source_version: ${sourceVersion}
---
-->`;
}

/** Strip existing YAML frontmatter comment from OLX content */
function stripFrontmatter(content: string): string {
  const frontmatterRe = /^\s*<!--\s*\n---[\s\S]*?---\s*\n\s*-->\s*\n?/;
  return content.replace(frontmatterRe, '').trimStart();
}

async function doTranslation(
  sourceFileUri: string,
  targetLocale: string,
  sourceLocale: string
): Promise<{ ok: boolean; idMap?: any; error?: string }> {
  const fs = await import('fs/promises');

  // Convert file:// URI to relative path for the provider
  const absPath = sourceFileUri.startsWith('file://') ? sourceFileUri.slice(7) : sourceFileUri;
  const sourceRelPath = path.relative(path.resolve(contentDir), absPath);

  // 1. Read source file
  let sourceContent: string;
  let effectiveRelPath = sourceRelPath;
  try {
    const result = await provider.read(sourceRelPath);
    sourceContent = result.content;
  } catch (err: any) {
    return { ok: false, error: `Failed to read source file: ${err.message}` };
  }

  // If the source is itself a translation (autogenerated), follow source_file
  // back to the original. Always translate from the human-authored source,
  // never from another translation (avoids quality degradation and double-nesting).
  const autogenMatch = sourceContent.match(/autogenerated:\s*true/);
  const sourceFileMatch = sourceContent.match(/source_file:\s*(\S+)/);
  if (autogenMatch && sourceFileMatch) {
    const originalFileName = sourceFileMatch[1];
    effectiveRelPath = path.join(path.dirname(path.dirname(sourceRelPath)), originalFileName);
    try {
      const result = await provider.read(effectiveRelPath);
      sourceContent = result.content;
    } catch (err: any) {
      return { ok: false, error: `Failed to read original source file "${effectiveRelPath}": ${err.message}` };
    }
  }

  // 2. Check if translation already exists
  const targetRelPath = computeTranslationPath(effectiveRelPath, targetLocale);
  try {
    await provider.read(targetRelPath);
    // Already exists — re-sync and return blocks from both source and translated files
    await syncContentFromStorage();
    const translatedFileUri = `file://${path.resolve(contentDir, targetRelPath)}`;
    return { ok: true, idMap: getBlocksForFiles(sourceFileUri, translatedFileUri) };
  } catch {
    // Doesn't exist — proceed with translation
  }

  // 3. Call LLM
  const sourceLanguageName = getLanguageLabel(sourceLocale, 'en', 'name');
  const targetLanguageName = getLanguageLabel(targetLocale, 'en', 'name');

  const systemPrompt = `You are a translator for educational content in OLX (XML) format.

Rules:
- Translate ALL human-readable text content (text between tags, attribute values like "title", "label", "placeholder", "description")
- PRESERVE all XML tags, tag names, id attributes, and structural attributes unchanged
- Do NOT translate: id values, ref values, tag names, CSS classes, LaTeX formulas, code blocks
- Output ONLY the translated OLX - no explanations, no markdown fencing, no commentary
- Maintain the exact same XML structure and nesting
- For mathematical content, preserve formulas but translate surrounding text
- Use natural, culturally appropriate phrasing`;

  let translatedContent: string;
  try {
    translatedContent = await callLLM([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: `Translate the following OLX content from ${sourceLanguageName} to ${targetLanguageName}:\n\n${sourceContent}` },
    ]);
    translatedContent = stripCodeFences(translatedContent);
  } catch (err: any) {
    return { ok: false, error: `LLM translation failed: ${err.message}` };
  }

  if (!translatedContent.trim()) {
    return { ok: false, error: 'LLM returned empty translation' };
  }

  // 4. Build translated file with metadata
  const sourceVersion = hashContent(sourceContent);
  const sourceFileName = path.basename(effectiveRelPath);
  const frontmatter = buildFrontmatter(targetLocale, sourceFileName, sourceVersion);
  const strippedTranslation = stripFrontmatter(translatedContent);
  const fileContent = `${frontmatter}\n${strippedTranslation}`;

  // 5. Write translated file (create parent directory first)
  try {
    const fullTargetPath = path.resolve(contentDir, targetRelPath);
    await fs.mkdir(path.dirname(fullTargetPath), { recursive: true });
    await provider.write(targetRelPath, fileContent);
  } catch (err: any) {
    return { ok: false, error: `Failed to write translation: ${err.message}` };
  }

  // 6. Re-sync content, return blocks from both source and translated files.
  // Both are needed because auto-generated child IDs differ between languages.
  await syncContentFromStorage();
  const translatedFileUri = `file://${path.resolve(contentDir, targetRelPath)}`;
  return { ok: true, idMap: getBlocksForFiles(sourceFileUri, translatedFileUri) };
}

// =============================================================================
// Route Handler
// =============================================================================

export async function POST(request: Request) {
  try {
    const { blockId, targetLocale, sourceLocale } = await request.json();

    if (!blockId || !targetLocale || !sourceLocale) {
      return NextResponse.json(
        { ok: false, error: 'Missing required fields: blockId, targetLocale, sourceLocale' },
        { status: 400 }
      );
    }

    // Validate locale format (BCP 47: alphanumeric segments separated by hyphens)
    //
    // Paths should be validated by the storage provider before write, but this is
    // part of defense-in-depth. It will need to be expanded when variants expand
    // beyond locale.
    const bcp47Re = /^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*$/;
    if (!bcp47Re.test(targetLocale) || !bcp47Re.test(sourceLocale)) {
      return NextResponse.json(
        { ok: false, error: 'Invalid locale format' },
        { status: 400 }
      );
    }

    // Stub mode: no real translation available
    if (getProvider().provider === 'stub') {
      return NextResponse.json(
        { ok: false, error: 'LLM is in stub mode — no real translation available' }
      );
    }

    // Look up source file from blockId + sourceLocale
    const sourceFileUri = getSourceFile(blockId, sourceLocale);
    if (!sourceFileUri) {
      return NextResponse.json(
        { ok: false, error: `Block "${blockId}" not found for locale "${sourceLocale}"` },
        { status: 404 }
      );
    }

    // Dedup: if same file+locale is already in flight, await that instead
    const dedupeKey = `${sourceFileUri}::${targetLocale}`;
    if (inFlightTranslations.has(dedupeKey)) {
      const result = await inFlightTranslations.get(dedupeKey);
      return NextResponse.json(result);
    }

    const promise = doTranslation(sourceFileUri, targetLocale, sourceLocale);
    inFlightTranslations.set(dedupeKey, promise);

    try {
      const result = await promise;
      if (!result.ok) {
        return NextResponse.json(result, { status: 500 });
      }
      return NextResponse.json(result);
    } finally {
      inFlightTranslations.delete(dedupeKey);
    }
  } catch (error: any) {
    console.error('[/api/translate] Error:', error);
    return NextResponse.json(
      { ok: false, error: error.message || 'Unknown error' },
      { status: 500 }
    );
  }
}
